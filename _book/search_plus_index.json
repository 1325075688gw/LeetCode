{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction LeetCode刷题（python） Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:29 "},"临时草稿.html":{"url":"临时草稿.html","title":"临时草稿","keywords":"","body":"临时草稿 class Solution: def findMedianSortedArrays(self, nums1, nums2): tmp = nums1 + nums2 tmp.sort() num = len(tmp) // 2 return (tmp[num] + tmp[~num]) / 2 nums1.extend(nums2) when left def partition(nums, left, right): def partition(nums, left, right): # 经过分析知道 tmp = nums[left] # 经过分析知道,当left==right，调整已经完整，以tmp为界限的数组左边比右边小，所以我们当left def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" m = {'{':0,'[':0,'(':0,')':1,'}':1,']':1} pair = {'{':'}','[':']','(':')'} # stack stack = [] for ch in s: if m.get(ch) == 0: stack.insert(0,ch) else: if len(stack) > 0: tch = stack.pop(0) if pair[tch] != ch: return False else: return False return True if len(stack) == 0 else False a=[1] b=[1] for i in range(len(nums)-1): a.append(a[i]*nums[i]) b.append(b[i]*nums[-i-1]) res=[] for i in range(len(a)): res.append(a[i]*b[-i-1]) return res ​ 1.题目 2.分析 3.代码 def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n=len(nums) dic={} for x in nums: if x in dic: dic[x]+=1 else: dic[x]=1 return [x for x in dic.keys() if dic[x]>n/3] class Solution(object): def mergeKLists(self, lists): \"\"\" :type lists: List[ListNode] :rtype: ListNode \"\"\" def merge(a, b): head = ListNode(0) cur = head while a and b: if a.val > b.val: cur.next = b b = b.next else: cur.next = a a = a.next cur = cur.next if a: cur.next = a if b: cur.next = b return head.next # 采用分治法 n = len(lists) if n == 0: return None def deal(l, r): if l > r: return None if l == r: return lists[0] middle = (l+r) // 2 a = deal(l, middle) b = deal(middle+1, r) return merge(a, b) return deal(0, n-1) def detectCycle(self, head): a = {} while head: if head in a: return head a[head] = \"\" head = head.next \"\"\" :type s: str :rtype: str \"\"\" for i in s: if i ==' ' : return ' '.join(s[::-1].split()[::-1]) return s[::-1] ​ if not s: return '' tmp = s.split(' ') ans = ' '.join(each[::-1] for each in tmp) return ans # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None def get_right(head, end=None): # 检测是否有序并寻找右侧节点 i = 0 cur = head is_inc = True while cur.next != end: last_val = cur.val cur = cur.next if cur.val ListNode: if not head: return head sort(head, None) return head Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:30 "},"LeetCode刷题优先顺序.html":{"url":"LeetCode刷题优先顺序.html","title":"LeetCode刷题顺序","keywords":"","body":"LeetCode刷题优先顺序 ID Question Diff Freq Data Structure Algorithms 1 Two Sum 2 5 array sort set Two Pointers 2 Add Two Numbers 3 4 linked list Two Pointers Math 3 Longest Substring Without Repeating Characters 3 2 string Two Pointers hashtable 4 Median of Two Sorted Arrays 5 3 array Binary Search 5 Longest Palindromic Substring 4 2 string 6 ZigZag Conversion 3 1 string 7 Reverse Integer 2 3 Math 8 String to Integer (atoi) 2 5 string Math 9 Palindrome Number 2 2 Math 10 Regular Expression Matching 5 3 string Recursion DP 11 Container With Most Water 3 2 array Two Pointers 12 Integer to Roman 3 4 Math 13 Roman to Integer 2 4 Math 14 Longest Common Prefix 2 1 string 15 3Sum 3 5 array Two Pointers 16 3Sum Closest 3 1 array Two Pointers 17 Letter Combinations of a Phone Number 3 3 string DFS 18 4Sum 3 2 array 19 Remove Nth Node From End of List 2 3 linked list Two Pointers 20 Valid Parentheses 2 5 string Stack 21 Merge Two Sorted Lists 2 5 linked list sort Two Pointers merge 22 Generate Parentheses 3 4 string DFS 23 Merge k Sorted Lists 3 4 linked list sort heap Two Pointers merge 24 Swap Nodes in Pairs 2 4 linked list 25 Reverse Nodes in k-Group 4 2 linked list Recursion Two Pointers 26 Remove Duplicates from Sorted Array 1 3 array Two Pointers 27 Remove Element 1 4 array Two Pointers 28 Implement strStr() 4 5 string Two Pointers KMP rolling hash 29 Divide Two Integers 4 3 Binary Search Math 30 Substring with Concatenation of All Words 3 1 string Two Pointers 31 Next Permutation 5 2 array permutation 32 Longest Valid Parentheses 4 1 string DP 33 Search in Rotated Sorted Array 4 3 array Binary Search 34 Search for a Range 4 3 array Binary Search 35 Search Insert Position 2 2 array 36 Valid Sudoku 2 2 array 37 Sudoku Solver 4 2 array DFS 38 Count and Say 2 2 string Two Pointers 39 Combination Sum 3 3 array combination 40 Combination Sum II 4 2 array combination 41 First Missing Positive 5 2 array sort 42 Trapping Rain Water 4 2 array Two Pointers Stack 43 Multiply Strings 4 3 string Two Pointers Math 44 Wildcard Matching 5 3 string Recursion DP greedy 45 Jump Game II 4 2 array 46 Permutations 3 4 array permutation 47 Permutations II 4 2 array permutation 48 Rotate Image 4 2 array 49 Anagrams 3 4 string hashtable 50 Pow(x, n) 3 5 Binary Search Math 51 N-Queens 4 3 array DFS 52 N-Queens II 4 3 array DFS 53 Maximum Subarray 3 3 array DP 54 Spiral Matrix 4 2 array 55 Jump Game 3 2 array 56 Merge Intervals 4 5 array sort linked list merge red-black tree 57 Insert Interval 4 5 array sort linked list merge red-black tree 58 Length of Last Word 1 1 string 59 Spiral Matrix II 3 2 array 60 Permutation Sequence 5 1 permutation Math 61 Rotate List 3 2 linked list Two Pointers 62 Unique Paths 2 3 array DP 63 Unique Paths II 3 3 array DP 64 Minimum Path Sum 3 3 array DP 65 Valid Number 2 5 string Math 66 Plus One 1 2 array Math 67 Add Binary 2 4 string Two Pointers Math 68 Text Justification 4 2 string 69 Sqrt(x) 4 4 Binary Search 70 Climbing Stairs 2 5 DP 71 Simplify Path 3 1 string Stack 72 Edit Distance 4 3 string DP 73 Set Matrix Zeroes 3 5 array 74 Search a 2D Matrix 3 3 array Binary Search 75 Sort Colors 4 2 array sort Two Pointers 76 Minimum Window Substring 4 2 string Two Pointers 77 Combinations 3 4 combination 78 Subsets 3 4 array Recursion combination 79 Word Search 3 4 array DFS 80 Remove Duplicates from Sorted Array II 2 2 array Two Pointers 81 Search in Rotated Sorted Array II 5 3 array Binary Search 82 Remove Duplicates from Sorted List II 3 3 linked list Recursion Two Pointers 83 Remove Duplicates from Sorted List 1 3 linked list 84 Largest Rectangle in Histogram 5 2 array Stack 85 Maximal Rectangle 5 1 array DP Stack 86 Partition List 3 3 linked list Two Pointers 87 Scramble String 5 2 string Recursion DP 88 Merge Sorted Array 2 5 array Two Pointers merge 89 Gray Code 4 2 combination 90 Subsets II 4 2 array Recursion combination 91 Decode Ways 3 4 string Recursion DP 92 Reverse Linked List II 3 2 linked list Two Pointers 93 Restore IP Addresses 3 3 string DFS 94 Binary Tree Inorder Traversal 4 3 tree Recursion hashtable morris Stack 95 Unique Binary Search Trees II 4 1 tree DP DFS 96 Unique Binary Search Trees 3 1 tree DP 97 Interleaving String 5 2 string Recursion DP 98 Validate Binary Search Tree 3 5 tree DFS 99 Recover Binary Search Tree 4 2 tree DFS 100 Same Tree 1 1 tree DFS 101 Symmetric Tree 1 2 tree DFS 102 Binary Tree Level Order Traversal 3 4 tree BFS 103 Binary Tree Zigzag Level Order Traversal 4 3 queue BFS tree Stack 104 Maximum Depth of Binary Tree 1 1 tree DFS 105 Construct Binary Tree from Preorder and Inorder Tr 3 3 array DFS tree 106 Construct Binary Tree from Inorder and Postorder T 3 3 array DFS tree 107 Binary Tree Level Order Traversal II 3 1 tree BFS 108 Convert Sorted Array to Binary Search Tree 2 3 tree DFS 109 Convert Sorted List to Binary Search Tree 4 3 linked list Recursion Two Pointers 110 Balanced Binary Tree 1 2 tree DFS 111 Minimum Depth of Binary Tree 1 1 tree DFS 112 Path Sum 1 3 tree DFS 113 Path Sum II 2 2 tree DFS 114 Flatten Binary Tree to Linked List 3 3 tree Recursion Stack 115 Distinct Subsequences 4 2 string DP 116 Populating Next Right Pointers in Each Node 3 3 tree DFS 117 Populating Next Right Pointers in Each Node II 4 2 tree DFS 118 Pascal's Triangle 2 1 array 119 Pascal's Triangle II 2 1 array 120 Triangle 3 1 array DP 121 Best Time to Buy and Sell Stock 2 1 array DP 122 Best Time to Buy and Sell Stock II 3 1 array greedy 123 Best Time to Buy and Sell Stock III 4 1 array DP 124 Binary Tree Maximum Path Sum 4 2 tree DFS 125 Valid Palindrome 2 5 string Two Pointers 126 Word Ladder II 1 1 127 Word Ladder 3 5 graph BFS shortest path 128 Longest Consecutive Sequence 4 3 array 129 Sum Root to Leaf Numbers 2 4 tree DFS 130 Surrounded Regions 4 3 array BFS DFS 131 Palindrome Partitioning 3 4 string DFS 132 Palindrome Partitioning II 4 3 string DP Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:26 "},"数字运算/":{"url":"数字运算/","title":"数字运算","keywords":"","body":"数字运算 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-08 00:43:19 "},"数字运算/2的幂_LeetCode_231.html":{"url":"数字运算/2的幂_LeetCode_231.html","title":"2的幂_LeetCode_231","keywords":"","body":"2的幂(LeetCode 231) 1.题目 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 输入: 1 输出: true 解释: 20 = 1 示例 2: 输入: 16 输出: true 解释: 24 = 16 示例 3: 输入: 218 输出: false 2.分析 从二进制上看，2的幂一定是这样的形式：整个二进制数上只有一位是1，其他位全是0； 如果有两个1，一定不是2的幂） 此时，n-1的二进制数一定会是当前位变为0，其他位全是1，这样n与n-1操作，就会是0； 3.代码 def isPowerOfTwo(self, n: int) -> bool: if(n Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:26 "},"数字运算/只出现一次的数字.html":{"url":"数字运算/只出现一次的数字.html","title":"只出现一次的数字","keywords":"","body":"只出现一次的数字 1.题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 2.分析 异或解决 3.代码 3.1异或解决 # 异或解决 def singleNumber(self, nums): a = 0 for num in nums: a = a ^ num return a 3.2常规解决 def singleNumber(self, nums: List[int]) -> int: bag = {} for i in nums: if i not in bag: bag[i] = 1 else: bag[i] += 1 # a = filter(lambda x:bag[x] ==1,bag) # return a.__next__() for i in bag: if bag[i] == 1: return i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:41 "},"数字运算/求众数 LeetCode 169.html":{"url":"数字运算/求众数 LeetCode 169.html","title":"求众数_LeetCode 169.md","keywords":"","body":"求众数(LeetCode 169) 1.题目 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 2.分析 我们一直有一个条件没有使用 众数是指在数组中出现次数大于n/2 的元素。那么问题就很容易了，我们可以先将nums排序，然后返回中间元素的值即可（众数的个数大于一半，排好序的nums中间元素一定是众数） 3.代码 Counter模块 def majorityElement(self, nums): from collections import Counter most_val = Counter(nums).most_common(1) return most_val[0][0] 利用n/2条件 # def majorityElement(self, nums): # nums.sort() # return nums[len(nums)//2] 字典 def majorityElement(self, nums: List[int]) -> int: bag = {} for i in nums: if i not in bag: bag[i] = 1 else: bag[i] += 1 return max(bag,key = bag.get) 摩根投票法 def majorityElement(self, nums): num, count = None, 0 for i in nums: if num == i:count+=1 elif count == 0: num, count = i, 1 else: count -= 1 return num 摩尔投票算法 假设有这样一个场景：票选村长，每人可投一票，我们将候选村长从1开始编号，村民们在票上写上候选村长的编号即可完成投票。那么最后统计的票可形成一个整型数组。那么谁是村长呢？票数过半的那个人。 摩尔投票算法可以快速的计算出一个数组中出现次数过半的数即大多数（majority），算法核心思想是同加，异减。我们举个例子。 假设数组是：[1,2,1,1,2,1]。算法步骤如下： 1。当前大多数是1，得分置1 2。与当前大多数不同，得分 - 1，得分为0，当前大多数 = 1 1。与当前大多数不同，得分为0，所以设置当前大多数 1 -> 1，得分置1 1。与当前大多数相同，得分 + 1，得分为2，当前大多数 = 1 2。与当前大多数不同，得分 - 1 ，得分为1，当前大多数 = 1 1。与当前大多数相同，得分 + 1，得分为2，当前大多数 = 1 这意味着1是这个数组中出现次数过半的数。 可以感受得到，算法会保存一个当前大多数，和得分，当遇到一个数不是当前大多数时，得分会减一，当减到0时，大多数会发生改变，并且重置得分为1。 这里需要区分的是，摩尔算法不能用来得到众数（mode），例如数组：[1,1,1,2,2,3,3,4,4]，摩尔算法得出最后的结果应该是4，但4并不是众数，可是显然4也不是大多数，那是因为，大多数是指出现次数过半的数，而这个数组中没有这样的数，所以摩尔算法是是失效的，对于这种情况采取需要重新投票。 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:03 "},"数字运算/求众数 II LeetCode 229.html":{"url":"数字运算/求众数 II LeetCode 229.html","title":"求众数 II LeetCode 229","keywords":"","body":"求众数 II(LeetCode 229) 1.题目 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。 示例 1: 输入: [3,2,3] 输出: [3] 示例 2: 输入: [1,1,1,3,3,2,2,2] 输出: [1,2] 2.分析 摩根投票法 如果我们在使用摩尔算法时，同时记录两个大多数，会怎么样呢？直觉告诉我，这会得到一个大多数，和一个出现次数仅次于大多数的数，但是这两个数不一定会比数组长的1/3大 所以我们得到它们后，还需要检查它们出现的次数是否符合条件。 3.代码 def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" a, b, ca, cb, ans = None, None, 0, 0, [] for i in nums: if i == a: ca += 1 elif i == b: cb += 1 elif ca == 0: a, ca = i, 1 elif cb == 0: b, cb = i, 1 else: ca, cb = ca - 1, cb - 1 # print(a, b) ca, cb = 0, 0 for i in nums: if i == a: ca += 1 elif i == b: cb += 1 if ca > len(nums)//3: ans.append(a) if cb > len(nums)//3: ans.append(b) return ans # print(a, b) 不检验的结果 输入 [3,2,3,2,3,2,3,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1] stdout 1 2 输出 [1] 预期结果 [1] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:03 "},"数字运算/整数反转 LeetCode 7.html":{"url":"数字运算/整数反转 LeetCode 7.html","title":"整数反转 LeetCode 7","keywords":"","body":"整数反转(LeetCode 7) 1.题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 2.分析 3.代码 def reverse(self, x: 'int') -> 'int': if x (2**31-1): return 0 x = str(x) if x[0] == '-': x = x[1:] str_x = ''.join(list(reversed(x))) str_x = '-'+str_x else: str_x = ''.join(list(reversed(x))) if int(str_x) (2**31-1): return 0 return int(str_x) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:59 "},"数字运算/格雷编码_LeetCode_89.html":{"url":"数字运算/格雷编码_LeetCode_89.html","title":"格雷编码_LeetCode_89","keywords":"","body":"格雷编码(LeetCode 89) 1.题目 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例 1: 输入: 2 输出: [0,1,3,2] 解释: 00 - 0 01 - 1 11 - 3 10 - 2 对于给定的 n，其格雷编码序列并不唯一。 例如，[0,2,3,1] 也是一个有效的格雷编码序列。 00 - 0 10 - 2 11 - 3 01 - 1 示例 2: 输入: 0 输出: [0] 解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 2.分析 .assets\\20180703120635594.png) .assets\\2018070312065295.png) 3.代码 def grayCode(self, n: int) -> List[int]: res = [] for i in range(2**n): res.append(i^(i>>1)) # print(res) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:02 "},"数字运算/两数相除_LeeetCode_29.html":{"url":"数字运算/两数相除_LeeetCode_29.html","title":"两数相除_LeeetCode_29","keywords":"","body":"两数相除(LeetCode_29) 1.题目 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1: 输入: dividend = 10, divisor = 3 输出: 3 示例 2: 输入: dividend = 7, divisor = -3 输出: -2 说明: - 被除数和除数均为 32 位有符号整数。 - 除数不为 0。 - 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 2.分析 明确一点,10进制数扩大两倍,左移一位 a = 2 a > = 1 输出: b = 4 当被除数大于等于除数时(否则的话就为0了),我们设置两个变量tmp_cs和tmp_res,并分别初始化为临时除数(除数后面会变化,过一会就知道了)和1(最小的情况),当被除数大于等于tmp_cs的二倍时bcs>=(tmp_cs=8*2,所以我们有两个8,所以tmp_res扩大两倍,除数也变为原来两倍16,继续循环,被除数47>=16*2,所以tmp_res = 2*2....后面继续判断,不赘述了)同时扩大二倍(左移)，并将返回值加上tmp_res，除数减去tmp_res。 拿十进制举例:29除以8，8扩大二倍，16小于29，再扩大二倍，超过29，于是29减去之前的16(我们保存了的)，返回值加上2(因为现在我们除的是16,16是8的2倍)。剩余除数为29-16=13，第二次循环时因为此时的13小于8的二倍(tmp_cs 3.代码 暴力法 (每次减去一个除数，统计可以减去多少个除数) class Solution: def divide(self, dividend: int, divisor: int) -> int: res = 0 sign = 1 if dividend ^ divisor > 0 else -1 dividend = abs(dividend) divisor = abs(divisor) while dividend >= divisor: dividend -= divisor res += 1 res = res if sign > 0 else -res return max(res, -2**31) if res (除数倍增法) 移位法 class Solution: def divide(self, dividend, divisor): sign = (dividend > 0) ^ (divisor > 0) i, bcs, cs = 0, abs(dividend), abs(divisor) if bcs == 0 or bcs = cs: tmp_cs, tmp_res = cs, 1 while bcs>=(tmp_cs 除数倍增法 class Solution: def divide(self, dividend, divisor): sign = (dividend > 0) ^ (divisor > 0) i, bcs, cs = 0, abs(dividend), abs(divisor) if bcs == 0 or bcs = cs: tmp_cs, tmp_res = cs,1 while bcs>=(tmp_cs+tmp_cs): tmp_res += tmp_res tmp_cs += tmp_cs bcs = bcs-tmp_cs res = res + tmp_res res = -res if sign else res return max(res, -2**31) if res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 12:26:00 "},"数字运算/10进制转化为其它进制.html":{"url":"数字运算/10进制转化为其它进制.html","title":"10进制转化为其它进制","keywords":"","body":"方法非常简单，就是利用辗转相除发， 保存商和余数，知道商为0为止，再将余数反转。 用列表a=[0,1,2,3,4,5,6,7,8,9,’A’,’b’,’C’,’D’,’E’,’F’]储存转换之后的每一位，直接用余数作为指针即可找到对应的符号。 def f(n,x): #n为待转换的十进制数，x为想转为的进制，取值为2-16 a=[0,1,2,3,4,5,6,7,8,9,'A','b','C','D','E','F'] b = [] while 1: # divmod 同时算出商和余数 divmod(6,3) == 2,0 s = n//x # 商 y = n%x # 余数 b.append(y) if s == 0: break n = s b.reverse() for i in b: print(a[i],end='') print(b) f(26,16) 系统自带方法 dec = int(input(\"输入数字：\")) print(\"十进制数为：\", dec) print(\"转换为二进制为：\", bin(dec)) print(\"转换为八进制为：\", oct(dec)) print(\"转换为十六进制为：\", hex(dec)) 结果： python3 test.py 输入数字：5 十进制数为：5 转换为二进制为： 0b101 转换为八进制为： 0o5 转换为十六进制为： 0x5 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-26 12:10:32 "},"数字运算/二进制求和_LeetCode_67.html":{"url":"数字运算/二进制求和_LeetCode_67.html","title":"二进制求和_LeetCode_67","keywords":"","body":"二进制求和 1.题目 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = \"11\", b = \"1\" 输出: \"100\" 示例 2: 输入: a = \"1010\", b = \"1011\" 输出: \"10101\" 2.分析 法一：将2进制数转为10进制计算，然后转化为二进制 法二：模仿10进制，字符串相加，这儿我们同样可以将直接利用字符串，也可以将字符串先转化为列表。 3.代码 法一 class Solution: def addBinary(self, a: str, b: str) -> str: a = int(a, 2) b = int(b, 2) return bin(a+b)[2:] 法二 def addBinary(self, a: str, b: str) -> str: res = '' tmp = 0 a_len = len(a) b_len = len(b) while a_len>0 or b_len>0 or tmp: a_len -= 1 b_len -= 1 i = a[a_len] if a_len>=0 else 0 j = b[b_len] if b_len>=0 else 0 s,y = divmod(int(i)+int(j)+tmp, 2) res = str(y) + res tmp = s return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-15 15:25:09 "},"数字运算/输出1+2+...+n_短路原理.html":{"url":"数字运算/输出1+2+...+n_短路原理.html","title":"输出1+2+...+n_短路原理","keywords":"","body":"求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 要注意python中逻辑运算符的用法，a and b，a为False，返回a，a为True，就返回b class Solution: def Sum_Solution(self, n): res = n tmp = res and self.Sum_Solution(n-1) return res+tmp Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 21:27:17 "},"数字运算/打印1~n,短路原理.html":{"url":"数字运算/打印1~n,短路原理.html","title":"打印1~n,短路原理","keywords":"","body":"正序输出 def func(n): res = n-1 res & func(n-1) print(res+1) 输出： func(6) 1，2，3，4，5，6 倒序输出 def func(n): print(n) n-1 & func(n-1) 输出： func(6) 6,5,4,3,2,1 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 21:34:54 "},"数字运算/数组中只出现一次的数_两个.html":{"url":"数字运算/数组中只出现一次的数_两个.html","title":"数组中只出现一次的数_两个","keywords":"","body":"题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 二、题目 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 1、思路 大家首先想到的是顺序扫描法，但是这种方法的时间复杂度是O（n^2）。接着大家又会考虑用哈希表的方法，但是空间复杂度不是O（1）。 应该怎么做才能即满足时间复杂度是O（n）又满足空间复杂度是O（1）的要求呢？ 我们可以想一想“异或”运算的一个性质，我们直接举例说明。 举例：{2,4,3,6,3,2,5,5} 这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？ 我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 # -*- coding:utf-8 -*- class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here res = 0 for i in array: res ^= i index = 0 while True: if res&1 ==0: index += 1 res >>= 1 else: break a = 0 b = 0 for i in array: if i>>index&1==1: a ^= i else: b ^= i return [a,b] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-19 00:10:51 "},"栈/":{"url":"栈/","title":"栈","keywords":"","body":"栈 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-08 00:43:19 "},"栈/逆波兰表达式.html":{"url":"栈/逆波兰表达式.html","title":"逆波兰表达式","keywords":"","body":"逆波兰表达式 波兰式、逆波兰式与表达式求值 1.题目 逆波兰表达式求值 根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入: [\"2\", \"1\", \"+\", \"3\", \"*\"] 输出: 9 解释: ((2 + 1) * 3) = 9 示例 2： 输入: [\"4\", \"13\", \"5\", \"/\", \"+\"] 输出: 6 解释: (4 + (13 / 5)) = 6 示例 3： 输入: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"] 输出: 22 解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 2.分析 3.代码1 class Solution: def evalRPN(self, tokens: List[str]) -> int: stack = [] op = [\"+\", \"-\", \"*\", \"/\"] for i in tokens: if i in op: t1 = stack.pop() t2 = stack.pop() if i=='+': stack.append(t2+t1) if i=='-': stack.append(t2-t1) if i=='*': stack.append(t2*t1) if i=='/': stack.append(int(t2/t1)) # 注意取整数 else: stack.append(int(i)) # 每次取出来的都是数字，而不是运算符 return stack.pop() 代码2 class Solution: def evalRPN(self, tokens): \"\"\" :type tokens: List[str] :rtype: int \"\"\" import operator stack = list() ops = { \"+\": operator.add, \"-\": operator.sub, \"*\": operator.mul, \"/\": operator.truediv} for char in tokens: if char in ops: t1 = int(stack.pop()) t2 = int(stack.pop()) stack.append(ops[char](t2, t1)) else: stack.append(int(char)) return stack.pop() 1.中缀表达式 人类最熟悉的一种表达式1+2，(1+2)*3，3+4*2+4等等都是中缀表示法。对于人们来说，也是最直观的一种求值方式，先算括号里的， 然后算乘除，最后算加减，但是，计算机处理中缀表达式却并不方便，因为没有一种简单的数据结构可以方便从一个表达式中间抽出 一部分算完结果，再放进去，然后继续后面的计算（链表也许可以，但是，代价也是不菲）。 在介绍前缀，后缀表达式之前，我想先通过我们最熟悉的中缀表达式画出一棵语法树来直观认识前后缀表达式。以A+B(C-D)-EF为例： 则中缀表达式得名于它是由相应的语法树的中序遍历的结果得到的。 2.前缀缀表达式 　　前缀表达式又叫做波兰式。同样的道理，表达式的前缀表达式是由相应的语法树的前序遍历的结果得到的。 如上图的前缀表达式为- + A B - C D E F 由前缀表达式求出结果有下面两种思路： 　　1.从左至右扫描表达式，如果一个操作符后面跟着两个操作数时，则计算，然后将结果作为操作数替换(这个操作符和两个操作数)， 重复此步骤，直至所有操作符处理完毕。如-+AB-CDEF，扫描到-CD时，会计算C-D=C',表达式变成：-+ABC'EF 继续扫描到BC',计算BC'=B',表达式变成:-+AB'*EF,继续+AB'，依此类推。 　　2.由1.知，要多遍扫描表达式，并且需要将3个字符替换成1个，比较繁锁，我们可以用一个栈S2来实现计算，扫描从右往左进行， 如果扫描到操作数，则压进S2，如果扫描到操作符，则从S2弹出两个操作数进行相应的操作，并将结果压进S2(S2的个数出2个进1个), 当扫描结束后，S2的栈顶就是表达式结果。 3. 后缀表达式 　　后缀表达式又叫做逆波兰式。它是由相应的语法树的后序遍历的结果得到的。如上图的后缀表达式为： A B C D - + E F - 由前缀表达式求出结果十分方便，只需要用一个栈实现： 我们可以用一个栈S2来实现计算，扫描从左往右进行，如果扫描到操作数，则压进S2，如果扫描到操作符，则从S2弹出两个操作数 进行相应的操作，并将结果压进S2(S2的个数出2个进1个),当扫描结束后，S2的栈顶就是表达式结果。后缀表达式和前缀表达式看 起来就像一对逆过程，实际上并不是这样子，因为字符读取的时候都是从左往右的，所以，前缀表达式往往需要用两个栈来计算， 其中一个栈用来预处理：将字符串倒序压进栈中。 4.中缀表达式转换成后缀表达式 　　既然中缀表达式对于计算机的运算并不便利，而前缀后缀表达式的计算相对简单方便。因此，找到一种途径将中缀表达式 转换成前缀后缀表达式就十分重要。实际上，二者的转换算法看起来也很像一个逆过程。因此，我们着重讨论中缀转后缀。 从理论上讲，已知一棵二叉树的中序遍历序列，要求出它的后序遍历序列是不唯一的，即文法是有多义性的。但是，在这 里加上了优先级这一限制条件，转换就变得唯一了。 算法：中缀表达式转换成后缀表达式 输入：中缀表达式串 输出：后缀表达式串 PROCESS BEGIN: 1.从左往右扫描中缀表达式串s，对于每一个操作数或操作符，执行以下操作; 2.IF (扫描到的s[i]是操作数DATA) 　　　　　 将s[i]添加到输出串中; 3.IF (扫描到的s[i]是开括号'(') 将s[i]压栈; 4.WHILE (扫描到的s[i]是操作符OP) IF (栈为空 或 栈顶为'(' 或 扫描到的操作符优先级比栈顶操作符高) 将s[i]压栈; BREAK; ELSE 出栈至输出串中 5.IF (扫描到的s[i]是闭括号')') 栈中运算符逐个出栈并输出，直到遇到开括号'('; 开括号'('出栈并丢弃; 6.返回第1.步 　　 7.WHILE (扫描结束而栈中还有操作符) 操作符出栈并加到输出串中 PROCESS END 5.中缀表达式转换成前缀表达式 　　中缀表达式转换成前缀表达式和中缀表达式转换成后缀表达式十分类似，只需要将扫描方向由前往后变成由后往前， ​ 将'('改为')',')'改为'(',注意其中一个判断优先级的地方需要由>=变成>. Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 23:46:56 "},"栈/有效的括号_LeetCode_20.html":{"url":"栈/有效的括号_LeetCode_20.html","title":"有效的括号_LeetCode_20","keywords":"","body":"有效的括号(LeetCode_20) 1.题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true 2.分析 3.代码 清楚易懂 class Solution: def isValid(self, s: str) -> bool: # 没有括号,也叫做括号匹配 if not s:return True stack = [] if s[0] in ['}',']',')']: return False for i in s: if not stack: stack.append(i) continue tmp = stack[-1] if tmp == '{': if i != '}': stack.append(i) else: stack.pop() elif tmp == '[': if i != ']': stack.append(i) else: stack.pop() elif tmp == '(': if i != ')': stack.append(i) else: stack.pop() if not stack: return True else: return False 优化 class Solution(object): def isValid(self, s): stack = [] judge = {'()','[]','{}'} for i in s: if not stack: stack.append(i) else: # stack[-1]+ i字符串拼接 if stack[-1]+ i in judge: stack.pop() else: stack.append(i) return stack == [] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 20:01:32 "},"栈/最长有效括号_LeetCode_32.html":{"url":"栈/最长有效括号_LeetCode_32.html","title":"最长有效括号_LeetCode_32","keywords":"","body":"最长有效括号(LeetCode_32) 1.题目 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 输入: \"(()\" 输出: 2 解释: 最长有效括号子串为 \"()\" 示例 2: 输入: \")()())\" 输出: 4 解释: 最长有效括号子串为 \"()()\" 2.分析 3.代码 class Solution(object): def longestValidParentheses(self, s): stack = [] res = 0 start = 0 for i in range(len(s)): if not stack: if i == ')': # 只有连续))))),既不入栈,同时还要不断更新start start = i +1 elif i == '(': stack.append(i) else: if i == ')': tmp = stack.pop() if stack: # res = max(res, i-stack[-1]) res = max(res, i-tmp+1) else: res = max(res, i-start + 1) elif i == '(': stack.append(i) return res class Solution: def longestValidParentheses(self, s: str) -> int: if len(s) == 0: return 0 stack = [] max_len, start = 0, 0 for i in range(len(s)): if s[i] == \"(\": stack.append(i) if s[i] == \")\": if not stack: start = i + 1 # elif s[stack[-1]] == \"(\": else: stack.pop(-1) if not stack: max_len = max(max_len, i-start+1) else: max_len = max(max_len, i-stack[-1]) return max_len 动态规划 class Solution(object): def longestValidParentheses(self, s): n = len(s) if n=0: dp[i] = dp[i-1]+2 # 处理独立的括号对的情形 类似()()、()(()) if pre>0: # 处理只有一对()情况,不加判断,结果为4，当只有一对括号时，不需要向前扩展了 dp[i] += dp[pre-1] return max(dp) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 10:03:02 "},"双指针/":{"url":"双指针/","title":"双指针","keywords":"","body":"双指针 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-08 00:43:19 "},"双指针/将奇数放在偶数的前面.html":{"url":"双指针/将奇数放在偶数的前面.html","title":"将奇数放在偶数的前面","keywords":"","body":"将奇数放在偶数的前面 1.题目 将数组的奇数放到偶数的前面 2.分析 可以使用快速排序的思想 3.代码 3.1代码1（奇数放到偶数前） import random import sys sys.setrecursionlimit(1000000) from copy import deepcopy def resetArray(nums, left, right): # 当数组的数 >= 2 时才有交换的价值 while left 3.2代码2（为了保证代码的整齐性，可以简单封装一下） import random import sys sys.setrecursionlimit(1000000) from copy import deepcopy def _quick_sort(nums, left, right): # 至少有两个元素 if left = tmp: right -= 1 nums[left] = nums[right] while left 3.3代码3（将整除3的放在前面） def resetArray(nums, left, right): while left Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 17:58:36 "},"双指针/有序数组的平方_LeetCode_977.html":{"url":"双指针/有序数组的平方_LeetCode_977.html","title":"有序数组的平方_LeetCode_977","keywords":"","body":"有序数组的平方(LeetCode_977) 1.题目 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2： 输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 2.分析 因为数组 A 已经排好序了， 所以可以说数组中的负数已经按照平方值降序排好了，数组中的非负数已经按照平方值升序排好了。 举一个例子，若给定数组为 [-3, -2, -1, 4, 5, 6]，数组中负数部分 [-3, -2, -1] 的平方为 [9, 4, 1]，数组中非负部分 [4, 5, 6] 的平方为 [16, 25, 36]。我们的策略就是从前向后遍历数组中的非负数部分，并且反向遍历数组中的负数部分。 两种双指针方法 3.代码 二分法：查找距离某个元素最近的位置 （如果存在该元素，就输出该元素位置）（此处查找0元素） 当前数组有序 li = [-5,-3,-1,2,3,6,7] def func(li): left,right = 0,len(li)-1 while left 0: right = mid-1 else: print('有相等元素,最近下标为',mid) return print(left,right) # 如果没有相等元素，最后left>right,且left=right+1 if li[left]-0 > 0-li[right]: print(\"没有相等，最近下标为\",right) return else: print('没有相等，最近下标为',left) return func(li) 普通法查找 li = [-5,-3,-1,0,2,3,6,7] def func(li): A = li[:] left, right = 0, len(A)-1 if A[0]>=0: print('最近下标为',0) return while leftli[left]-0: print(\"没有相等，最近下标为\",left) return else: print('没有相等，最近下标为',left-1) return func(li) 找到离0最近的值，向两边遍历 (找0时候用的是二分法查找，因为0应该在中间附近，二分法查找更快) class Solution: def sortedSquares(self, A: List[int]) -> List[int]: n = len(A) left, right = 0, n-1 if n == 1: return [A[0]**2] def func(li, left, right): while left 0: right = mid-1 elif li[mid] right,且left=right+1 if li[left]-0 > 0-li[right]: return right return left res = [] if A[0] 两边向中间遍历 class Solution(object): def sortedSquares(self, A): left, right = 0, len(A)-1 # 先定义好res,后面再相应位置修改res里面的值,而不是res = [],然后一个个添加元素,因为从两边向中间遍历,添加的元素从大到小,如果我们用res.append(...)，则最后需要res.resverse().如果添加元素时候，res.insert(0,...)则每次添加元素,其实内部都有大量操作(当前元素向后移位)。所以我们先定义好res.直接修改相应位置 res = [0] * (right+1) cur = right while left Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 17:18:27 "},"双指针/验证回文字符串2_LeetCode_680.html":{"url":"双指针/验证回文字符串2_LeetCode_680.html","title":"验证回文字符串2_LeetCode_680","keywords":"","body":"验证回文字符串 Ⅱ(LeetCode_680) 1.题目 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: \"aba\" 输出: True 示例 2: 输入: \"abca\" 输出: True 解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 2.分析 双指针 递归 原生 判断回文字符串 3.代码 双指针 class Solution: def validPalindrome(self, s: str) -> bool: if len(s) 递归 class Solution: def validPalindrome(self, s: str) -> bool: if len(s)0: return func(s,left+1,right,0) or func(s,left,right-1,0) else: return False return True return func(s,0,len(s)-1,1) 原生写法，通过率99.99%，超时，其它语言可通过 class Solution: def validPalindrome(self, s: str) -> bool: if not s:return True flag =True left, right = 0,len(s)-1 while left Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 17:27:36 "},"双指针/构成三角形的个数.html":{"url":"双指针/构成三角形的个数.html","title":"构成三角形的个数","keywords":"","body":"1.题目 给出一组序列,序列中的元素都大于0，则该序列中元素可以构成多少个三角形 2.分析 双指针法 先将数组排序，对于 a c,则可以构成三角形，`a c，则 3.代码 def numDupDigitsAtMostN(self, N: int) -> int: def func(li): li.sort() print(li) n = len(li) left, right = 0, n-1 res = 0 for i in range(n-2): j = i+1 while j li[j+1]: j += 1 res += 1 print(res) func([2,3,4,5,6]) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 17:49:54 "},"双指针/反转字符串中的元音字母_LeetCode_345.html":{"url":"双指针/反转字符串中的元音字母_LeetCode_345.html","title":"反转字符串中的元音字母_LeetCode_345","keywords":"","body":"反转字符串中的元音字母(LeetCode_345) 1.题目 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。交换左右两边的元音字母 示例 1: 输入: \"hello\" 输出: \"holle\" 示例 2: 输入: \"leetcode\" 输出: \"leotcede\" 说明: 元音字母不包含字母\"y\"。 2.分析 ... 3.代码 class Solution: def reverseVowels(self, s: str) -> str: if not s:return '' left, right = 0, len(s)-1 # print(right) s = list(s) tmp = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'] while left Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 17:54:09 "},"双指针/平方数之和_LeetCode_633.html":{"url":"双指针/平方数之和_LeetCode_633.html","title":"平方数之和_LeetCode_633","keywords":"","body":"平方数之和(LeetCode_633) 1.题目 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1: 输入: 5 输出: True 解释: 1 * 1 + 2 * 2 = 5 示例2: 输入: 3 输出: False 2.分析 ... 3.代码 from math import * class Solution: def judgeSquareSum(self, c: int) -> bool: left,right = 0,int(sqrt(c))+1 while left c: right -= 1 elif tmp Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 18:07:42 "},"双指针/合并两个有序数组_LeetCode_88.html":{"url":"双指针/合并两个有序数组_LeetCode_88.html","title":"合并两个有序数组_LeetCode_88","keywords":"","body":"合并两个有序数组(LeetCode_88) 1.题目 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 2.分析 3.代码 class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None: \"\"\" Do not return anything, modify nums1 in-place instead. \"\"\" ''' 两个有序数组进行合并,就联想到归并排序。我们既可以从前往后归并，也可以从后往前归并。 但是本题nums1后面留的空间足够，所以我们在nums1尾部进行添加元素，不需要重新开辟数组进行归并。因此我们只能从后向前归并，因为nums2归并到nums1上，如果从前往后归并，那么需要不断调整nums1的值，防止nums1中未归并的值被覆盖丢失，相当复杂。而我们从后往前归并，就不需要这么复杂了。 我们归并的起点为m-1,n-1(因为这是下标表示，所以减一)。归并结果保存位置从 (m+n-1)开始(因为这是下标表示，所以减一)。归并起点和归并结果的位置都是从右向左前进。 第一轮循环合并完后，由于可能nums2指针未走完(n>=0:nums2还有元素比nums1最小元素小)，需要将nums2剩余首部覆盖至nums1首部。nums1指针未走完不需要做任何多余操作，因为覆盖前后相同。 nums1 = 【3,4,5,0,0】 nums2 = 【1,2】 第一个while循环跳出后, nums1 = [3,4,3,4,5] nums2 = [1,2] nums2的下标为 n=1 所以 用while循环将nums2依次添加到nums1 nums1 = 【1,2,5,0,0】 nums2 = 【3,4】 第一个while循环跳出后, nums1 = [1,2,3,4,5] nums2 = [] nums2 的下标为 n=-1 不用第二个循环 ''' # nums1 添加的新值的首下标 cur = m+n-1 n = n-1 m = m-1 while n>=0 and m>=0: if nums1[m]>nums2[n]: nums1[cur] = nums1[m] m -= 1 else: nums1[cur] = nums2[n] n -= 1 cur -= 1 while n>=0: nums1[cur] = nums2[n] n -= 1 cur -= 1 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 18:26:31 "},"二分/":{"url":"二分/","title":"二分","keywords":"","body":"二分 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-08 00:43:19 "},"二分/二分搜索.html":{"url":"二分/二分搜索.html","title":"二分搜索","keywords":"","body":"二分搜索 1. 二分搜索有递归和循环两种方式 2.1 递归实现二分查找 def func(li, item, left, right): if left item: right = mid - 1 return func(li, item, left, right)# 递归如果有返回值,所有调用的地方必须写return else: return True else: return False a = [2,3,32,2,23,2] b = func(a,2,0,len(a)-1) print(b) 2.2 递归二分搜索查找第二版本 def func(li, item, left, right): if left item: right = mid - 1 else: return True res = func(li, item, left, right) # 递归如果有返回值,所有调用的地方必须写return if not res: return False else: return True else: return False 2.3 循环实现二分搜索 def func(li, item): left, right = 0, len(li)-1 # 用while 就说明是循环，而不是靠func传没传left和right决定 while left item: right = mid - 1 else: return True return False Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 09:10:11 "},"二分/二叉搜索树中第K小的元素.html":{"url":"二分/二叉搜索树中第K小的元素.html","title":"二叉搜索树中第K小的元素","keywords":"","body":"二叉搜索树中第K小的元素 1.题目 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明： 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1: 输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 输出: 1 示例 2: 输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 输出: 3 2.分析 3.代码1 class Solution(object): def kthSmallest(self, root, k): \"\"\" :type root: TreeNode :type k: int :rtype: int \"\"\" arr = [] def inder(root, arr, k): if root: inder(root.left, arr, k) if len(arr) >= k: # print(root.val) return arr.append(root.val) inder(root.right, arr, k) inder(root, arr, k) # print(arr[-1]) # 必须这样，而不能直接在if语句返回 return arr[-1] return arr[-1] 代码2 class Solution(object): def countNodes(self, root): # 计算树的节点数 if root == None: return 0 else: return 1 + self.countNodes(root.left) + self.countNodes(root.right) def kthSmallest(self, root, k): \"\"\" :type root: TreeNode :type k: int :rtype: int \"\"\" # 先遍历所有的值，然后找到第k小的数字，最后利用二分搜索进行处理 if root == None: return None leftCount = self.countNodes(root.left) if k [!TIP] 计算树的节点数 def countNodes(self, root): if root == None: return 0 else: return 1 + self.countNodes(root.left) + self.countNodes(root.right) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:51:38 "},"二分/寻找两个有序数组的中位数.html":{"url":"二分/寻找两个有序数组的中位数.html","title":"寻找两个有序数组的中位数","keywords":"","body":"寻找两个有序数组的中位数 1.题目 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 2.分析 3.代码 3.1代码1 def findMedianSortedArrays(self, nums1: 'List[int]', nums2: 'List[int]') -> 'float': nums1.extend(nums2) nums1.sort() num_len = len(nums1) //2 return (nums1[num_len] + nums1[~num_len])/2 3.2代码2 def findMedianSortedArrays(self, nums1: 'List[int]', nums2: 'List[int]') -> 'float': a = nums1 b = nums2 a_flag = 0 b_flag = 0 res = [] if not a: res = b b_flag = 1 if not b: res = a a_flag = 1 a_index = b_index = 0 while a_index 3.3代码3（归并的最后一次） def findMedianSortedArrays(self, nums1, nums2): res = [] num_len = (len(nums1)+len(nums2))//2 while nums1 and nums2: if nums1[-1] >= nums2[-1]: res.insert(0, nums1.pop()) else: res.insert(0, nums2.pop()) res = (nums1 or nums2) + res print(res) return (res[num_len] + res[~num_len])/2 3.4代码4（未完成） def findMedianSortedArrays(self, nums1, nums2): if not nums1 and not nums2: return elif not nums1 or not nums2: nums = nums1+nums2 nums_len = len(nums)//2 return (nums[nums_len] + nums[~nums_len])/2 print( self.findMedian(nums1, nums2)) def findMedian(self, nums1, nums2): if len(nums1) nums2[nums_2_mid]: self.findMedian(nums1[nums_1_mid:], nums2[:nums_2_mid]) elif nums1[nums_1_mid] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:57 "},"二分/找出数组中第K大的数.html":{"url":"二分/找出数组中第K大的数.html","title":"数组中第K大的数","keywords":"","body":"找出数组中第K大的数 1.题目 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 2.分析 可以用类似快速排序，也可以用类似冒泡排序 3.代码 class Solution: def findKthLargest(self, nums: List[int], k: int) -> int: if len(nums) == 1: return nums[0] mid = nums[0] right = [i for i in nums[1:] if i >= mid] left = [i for i in nums[1:] if i len(right): return self.findKthLargest(left, k-len(right)-1) else: return self.findKthLargest(right, k) 冒泡排序有错 def findKthLargest(self, nums, k): nums_len = len(nums) if nums_len == 1: return nums[0] res = 0 for i in range(k): # print(i) for j in range(nums_len-1-i): if nums[j] >= nums[j+1]: nums[j],nums[j+1] = nums[j+1],nums[j] if i==k-2 and j == nums_len-2-i: # print(nums[j]) return nums[j-1] > [!NOTE] > 这是一个简单的Note类型的使用，所有的属性都是默认值。 [!NOTE] 这是一个简单的Note类型的使用，所有的属性都是默认值。\\ > [!NOTE] > 这是一个简单的Note类型的使用，所有的属性都是默认值。 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:57 "},"二分/找出数组中唯一重复的元素.html":{"url":"二分/找出数组中唯一重复的元素.html","title":"找出数组中唯一重复的元素","keywords":"","body":"找出数组中唯一重复的元素 1.题目 ​ 数字1~1000存放在含有1001个元素组成的数组中，其中只有唯一的一个元素值重复，其他数字只出现一次，设计一个算法，将重复元素找出来，要求每个元素只能访问一次，如果不使用辅助存储空间，能否设计一个算法实现？ 2.分析 ​ 累加求和就去另一个累加求和 3.代码 3.1代码1（累加求和） def findDup(nums): min_num = float('inf') max_num = float('-inf') sum_1 = 0 sum_2 = 0 for i in nums: if i max_num: max_num = i sum_1 += i for i in range(min_num, max_num+1): sum_2 += i return abs(sum_1 - sum_2) print(findDup([0,1,2,3,4,5,5,6])) 3.2代码2（异或） def findDup(nums): nums_len = len(nums) i = 0 for j in nums: i ^= j # print(i) j = 1 while j [!TIP] 相同元素异或等于0，0与任何元素异或为该元素 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:57 "},"二分/找出数组中前k大.html":{"url":"二分/找出数组中前k大.html","title":"找出数组中前k大","keywords":"","body":"找出数值中前k大 1.题目 2.分析 通过分析，最大的前三个数比数值中其其它数都大，因此可以采用类似求最大值的方法来求前三名。初始化前三名为最小整数：r1,r2,r3。 然后遍历数组 如果当前值tmp > r1:r3=r2,r2=r1,r1=tmp 如果当前值tmp>r2且不等于r1：r3=r2,r2=tmp 如果当前值tmp大于r3且不等于r2,r3 = tmp 3.代码1 def findTop3(li): if li == None or len(li) r1: r3,r2,r1 = r2,r1,li[i] elif li[i]>r2: r3,r2 = r2,li[i] else: r3 = li[i] i += 1 print(\"前三名：\"+str(r1)+\",\"+str(r2)+\",\"+str(r3)) findTop([2,3,4,45,5,5]) 代码2（堆排序） import heapq li = list(range(10)) random.shuffle(li) def topk(li, k): tmp = li[:k] heapq.heapify(tmp) for i in li[k:]: if i ​ Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:57 "},"二分/颜色分类.html":{"url":"二分/颜色分类.html","title":"颜色分类","keywords":"","body":"颜色分类(LeetCode_75) 1.题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 2.分析 3.代码 class Solution(object): # rtype: None Do not return anything, modify nums in-place instead. def sortColors(self, nums): left = -1 right = len(nums) curr = 0 while curr Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-21 03:18:01 "},"二分/快速排序解决奇偶问题.html":{"url":"二分/快速排序解决奇偶问题.html","title":"快速排序解决奇偶问题","keywords":"","body":"def partition(list1): \"\"\" 在[left, right]对list1 进行奇数、偶数划分 \"\"\" # 初始值 left = -1 right = len(nums) curr = 0 while curr Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-19 20:14:17 "},"二分/查找距离某个值最近的下标.html":{"url":"二分/查找距离某个值最近的下标.html","title":"查找距离某个值最近的下标","keywords":"","body":"数组有序，用二分 li = [-5,-3,-1,2,3,6,7] def func(li): left,right = 0,len(li)-1 while left 0: right = mid-1 else: print('有相等元素,最近下标为',mid) return print(left,right) # 如果没有相等元素，最后left>right,且left=right+1 if li[left]-0 > 0-li[right]: print(\"没有相等，最近下标为\",right) return else: print('没有相等，最近下标为',left) return func(li) 数组无序 li = [-5,-3,-1,0,2,3,6,7] def func(li): A = li[:] left, right = 0, len(A)-1 if A[0]>=0: print('最近下标为',0) return while leftli[left]-0: print(\"没有相等，最近下标为\",left) return else: print('没有相等，最近下标为',left-1) return func(li) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 18:29:48 "},"二分/寻找选择排序数组中最小值_LeetCode_153_中等.html":{"url":"二分/寻找选择排序数组中最小值_LeetCode_153_中等.html","title":"寻找选择排序数组中最小值LeetCode_153中等","keywords":"","body":"寻找旋转排序数组中的最小值(LeetCode153中等) 1.题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2] 输出: 1 示例 2: 输入: [4,5,6,7,0,1,2] 输出: 0 2.分析 等价于前面一堆0，后面一堆1，寻找第一个1的位置 # 1、nums[mid] > nums[right]：例子：[7, 8, 9, 10, 1, 2]，mid 肯定不是最小； # 2、否则，nums[mid] # 二分法：首先要判断这个有序数组是否旋转了，通过比较第一个和最后一个数的大小，如果第一个数小，则没有旋转，直接返回这个数。如果第一个数大，就要进一步搜索。我们定义left和right两个指针分别指向开头和结尾，还要找到中间那个数，然后和left指的数比较，如果中间的数大，则继续二分查找右半段数组，反之查找左半段。终止条件是当左右两个指针相邻，返回小的那个。 3.代码 def findMin(self, nums: List[int]) -> int: # 二分法：首先要判断这个有序数组是否旋转了，通过比较第一个和最后一个数的大小，如果第一个数小，则没有旋转，直接返回这个数。如果第一个数大，就要进一步搜索。我们定义left和right两个指针分别指向开头和结尾，还要找到中间那个数，然后和left指的数比较，如果中间的数大，则继续二分查找右半段数组，反之查找左半段。终止条件是当左右两个指针相邻，返回小的那个。 if not nums: return -1 if len(nums) == 1: return nums[0] if nums[0] nums[mid]: return nums[mid] elif nums[mid+1] nums[left]: left = mid else: # 分治法 return min(self.findMin_1(nums, left, mid-1), self.findMin_1(nums, mid+1, right)) 递归 def findMin(self, nums: List[int]) -> int: # 二分法：首先要判断这个有序数组是否旋转了，通过比较第一个和最后一个数的大小，如果第一个数小，则没有旋转，直接返回这个数。如果第一个数大，就要进一步搜索。我们定义left和right两个指针分别指向开头和结尾，还要找到中间那个数，然后和left指的数比较，如果中间的数大，则继续二分查找右半段数组，反之查找左半段。终止条件是当左右两个指针相邻，返回小的那个。 left, right = 0, len(nums)-1 return self.findMin_1(nums, left, right) def findMin_1(self, nums, left, right): if left == right: return nums[left] if left + 1 == right: return min(nums[left], nums[right]) mid = (left+right)//2 return min(self.findMin_1(nums, left, mid), self.findMin_1(nums, mid+1, right)) def findMin(self, nums): if not nums: return -1 if len(nums) == 1: return nums[0] if nums[0] nums[right]: left = mid+1 # 否则右边一定是有序的,但是mid这个位置可能会是最小值，所以下次还要继续搜索 else: right = mid # print(left, right) return nums[left] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-26 09:55:01 "},"二分/二分查找_LeetCode_704.html":{"url":"二分/二分查找_LeetCode_704.html","title":"二分查找_LeetCode_704","keywords":"","body":"二分查找(LeetCode704简单) 1.题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间 2.分析 https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/ https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/ 3.代码 class Solution: def search(self, nums: List[int], target: int) -> int: n = len(nums) if n == 0:return -1 left, right = 0, n-1 while left>1 if nums[mid] == target: return mid elif nums[mid] target: right = mid-1 return -1 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-26 10:13:18 "},"二分/搜索插入位置_LeetCode_35.html":{"url":"二分/搜索插入位置_LeetCode_35.html","title":"搜索插入位置_LeetCode_35","keywords":"","body":"搜索插入位置(LeetCode_35) 1.题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 2.分析 3.代码 class Solution: def searchInsert(self, nums: List[int], target: int) -> int: # 寻找插入点使用二分法，但与寻找某数字不同的是，需要考虑一些边界条件： # 当插入数字和nums中某数字相等时，插入到左边还是右边？本题要求插到左边； # 插入数字在nums第一个数字左边，或在最后一个数字右边； left, right = 0, len(nums) - 1 while left Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 19:05:38 "},"二分/x的平方根_LeetCode_69_简单.html":{"url":"二分/x的平方根_LeetCode_69_简单.html","title":"x的平方根LeetCode_69简单","keywords":"","body":"x 的平方根(LeetCode69简单) 1.题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 2.分析 牛顿法 如果我们要求a的平方根，首先令f(x)=x^2-a;那么我们的目的就是求得x使得f(x)=0; 由函数f(x)=x^2-a，我们求导可以知道，函数上任意一点(x,y)的切线的斜率为2x。 假设过点（x0,y0）的切线方程为y=kx+b，那么切线与x轴的交点横坐标为-b/k。 而b=y0-kx0,k=2x0,y0=x0^2-a,化简-b/k=（x0+a/x0）/2。 也就是说（x0+a/x0）/2是过点（x0,y0）的切线与x轴的交点的横坐标。 记（x0+a/x0）/2=x',继续求过点（x',f(x')）的切线与x轴的交点的横坐标x''，很明显x''比x'更靠近函数f(x)=x^2-a与x轴的交点的横坐标(即a的正平方根)。 ​ 3.代码 牛顿法** def mySqrt(self, x: int) -> int: # 牛顿法 if x 1*math.e**-9: r = (r+x/r)/2 return int(r) 二分法 def mySqrt(self, x): if x>1 sq = mid**2 if sq == x: return mid # elif sqx决定了最后非法循环出去时,left=right=mid-1还是left=right=mid+1 # 先写elif sqx: right = mid - 1 # if left**2 > x: # return left-1 # else: # return left # print(left,right) if right**2 > x: return right-1 else: return right Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-26 10:06:44 "},"二分/数字在排序数组中出现的次数.html":{"url":"二分/数字在排序数组中出现的次数.html","title":"数字在排序数组中出现的次数","keywords":"","body":"数字在排序数组中出现的次数 `//因为data中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5 //这两个数应该插入的位置，然后相减即可。 class Solution: def GetNumberOfK(self, data, k): # write code here def func(arr, k): left, right = 0, len(arr)-1 while left >1 if k>arr[mid]: left = mid + 1 else: right = mid - 1 return left return func(data, k+0.1) - func(data, k-0.1) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-19 00:37:43 "},"三数/":{"url":"三数/","title":"三数","keywords":"","body":"三数 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-08 00:43:19 "},"三数/最接近的三数之和.html":{"url":"三数/最接近的三数之和.html","title":"最接近的三数之和","keywords":"","body":"最接近的三数之和 1.题目 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 2.分析 我们要将l=i+1、r=len(nums)-1这样初始化，因为我们希望在[l:r]中进行寻找操作。计算sum=nums[i]+nums[l]+nums[r]和target的差是多少，并且我们要记录下来，最后取最小的差对应的sum作为结果。当l 3.代码 代码1 def threeSumClosest(self, nums: 'List[int]', target: 'int') -> 'int': nums.sort() len_nums = len(nums) res = [] # 固定i，调整j和k for key, value in enumerate(nums[:len_nums-2]): l, r = key+1,len_nums-1 if nums[l] + nums[l+1] + value > target: res.append(nums[l] + nums[l+1] + value) elif nums[r] + nums[r-1] + nums[r-2] 代码2 def threeSumClosest(self, nums: 'List[int]', target: 'int') -> 'int': nums.sort() len_nums = len(nums) best_dist = float('inf') best_sum = 0 for key, value in enumerate(nums[:len_nums-2]): l, r = key+1,len_nums-1 while l Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:59 "},"三数/三数之和 腾讯.html":{"url":"三数/三数之和 腾讯.html","title":"三数之和（腾讯）","keywords":"","body":"三数之和（腾讯） 1.题目 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 2.分析 注意去重 【-2，-2，1，1】头去重 if i > 0 and nums[i] == nums[i-1]:continue 【-2，1，1，1】尾去重 while j 3.代码 def threeSum(self,nums: 'List[int]') -> 'List[List[int]]': if len(nums) 0: break if i > 0 and nums[i] == nums[i-1]: continue #记录下第二、第三个数的下标位置 j = i+1 k = len_nums - 1 while j 0: k -= 1 elif s Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:29 "},"三数/求最小三元组距离.html":{"url":"三数/求最小三元组距离.html","title":"求最小三元组距离","keywords":"","body":"求最小三元组距离 1.题目 ​ 已知升序整数数组a【l】,b【m】,c【n】,请在三个数组总各找一个元素，使得组成的三元组的距离最小，三元组距离的定义为Distance = max(abs(a[i]-b[j]), abs(a[i]-c[k]), abs(b[j]-c[k])),请计算最小三元组距离。 2.分析 ​ 最小距离法，数学运算法 数学云算法 Distance = 1/2 * (abs(a[i]-b[j]), abs(a[i]-c[k]), abs(b[j]-c[k])) 3.代码 def minDis(a, b, c): alen = len(a) blen = len(b) clen = len(c) min_dis = float('inf') i, j, k = 0, 0, 0 while True: tmp_dis = max(abs(a[i]-b[j]), abs(a[i]-c[k]), abs(b[j]-c[k])) if tmp_dis Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:23 "},"三数/三个数的最大乘积 LeetCode 628.html":{"url":"三数/三个数的最大乘积 LeetCode 628.html","title":"三个数的最大乘积 LeetCode 628","keywords":"","body":"三个数的最大乘积 LeetCode 628 1.题目 给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1: 输入: [1,2,3] 输出: 6 示例 2: 输入: [1,2,3,4] 输出: 24 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 2.分析 先排好序 然后取最大的3个数相乘，或者最小的两个数（负数）和最大的一个数相乘 3.代码 class Solution: def maximumProduct(self, nums: List[int]) -> int: nums.sort() return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3]) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:52:26 "},"区间搜索/":{"url":"区间搜索/","title":"区间搜索","keywords":"","body":"区间搜索 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 22:00:38 "},"区间搜索/接雨水 LeetCode 42.html":{"url":"区间搜索/接雨水 LeetCode 42.html","title":"接雨水_LeetCode 42","keywords":"","body":"接雨水(LeetCode_42) 1.题目 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 2.分析 这道题真正难点在于: 在一个位置能容下的雨水量等于它左右两边(并不要求最近的最高)柱子最大高度的最小值减去它的高度.比如下图所示, 位置i能容下雨水量:min(3,1) - 0 = 1 所以,问题就变成了: 如何找所有位置的左右两边的柱子的最大值? 单调栈 找最高点，然后从左右两边遍历到中间 动态规划 不用动态规划 3.代码 单调递增栈: ==注意：==因为左边和右边对于接雨水没有用，所以第一个元素的左边我们不需要加float('inf') ,最后个元素也不需要float('inf') class Solution: def trap(self, height: List[int]) -> int: # height = [float('inf')] + height[:] + [float('inf')] n = len(height) res = 0 stack = [] for i in range(n): while stack and height[i]>height[stack[-1]]: tmp = stack.pop() if not stack: break res += (min(height[stack[-1]],height[i])-height[tmp]) * (i-stack[-1] - 1) # print(res) stack.append(i) return res 单调递增栈 class Solution: def trap(self, height: List[int]) -> int: # height = [float('inf')] + height[:] + [float('inf')] n = len(height) res = 0 stack = [] for i in range(n): if not stack or height[i]=height[stack[-1]]: tmp = stack.pop() if stack: res += (min(height[stack[-1]],height[i])-height[tmp]) * (i-stack[-1]-1) else: # 左右两边界不能装水，所以我们不需要 height = [float('inf')] + height[:] + [float('inf')] pass stack.append(i) return res 找最高点，然后从左右两边遍历到中间 # 找到最高点,然后从左右两边遍历到中间 class Solution: def trap(self, height: List[int]) -> int: if len(height) == 1:return 0 res = 0 high_id = 0 high_num = height[0] # 找到最高点 n = len(height) for i in range(1,n): if height[i]>high_num: high_id = i high_num = height[i] # print(high_id) # print(high_num) # 从左边往最高点遍历 tmp = height[0] for i in range(0,high_id): if height[i] > tmp: tmp = height[i] else: res += (tmp-height[i]) # 从右边往最高点遍历 tmp = height[-1] for j in range(n-1,high_id,-1): if height[j] > tmp: tmp = height[j] else: res += (tmp-height[j]) return res 动态规划 class Solution: def trap(self, height: List[int]) -> int: n = len(height) if n height[i]: res += (tmp-height[i]) return res 不用动态规划 class Solution: def trap(self, height: List[int]) -> int: n = len(height) if n left[-1]: left.append(height[i]) else: left.append(left[-1]) right = [height[-1]] for j in range(n-1-1,-1,-1): if height[j] > right[0]: right.insert(0,height[j]) else: right.insert(0,right[0]) print(left) print(right) # 数组的端点，不可能盛水，所以跳过，不用遍历 for i in range(1,n-1): tmp = min(left[i], right[i]) # 当前柱子高度比左右两边都高，则该处不能盛水，跳过 if tmp>height[i]: res += (tmp-height[i]) return res 测试用例 输入：[0,1,0,2,1,0,1,3,2,1,2,1] stdout: [0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3] [3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1] 输出：6 预期结果：6 不用动态规划（...） class Solution: def trap(self, height: List[int]) -> int: n = len(height) if n == 1:return 0 res = 0 # 左右两边不可能盛水，所以跳过，不遍历 for i in range(1,n-1): left = 0 for j in range(0,i): if height[j]>left: left = height[j] right = 0 for j in range(i+1,n): if height[j]>right: right = height[j] tmp = min(right,left) if tmp>height[i]: res += (tmp-height[i]) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 23:56:30 "},"单调栈/":{"url":"单调栈/","title":"单调栈","keywords":"","body":"单调栈 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:54:05 "},"单调栈/单调栈原理.html":{"url":"单调栈/单调栈原理.html","title":"单调栈原理","keywords":"","body":"性质 - 单调栈是一种特殊性质的栈，特殊之处在于栈内的元素都保持一个单调性 单调栈: - 入栈、出栈的地方叫做栈顶 - 栈的最底部，叫做栈底 单调递增栈:从栈顶到栈底严格单调递增 单调递减栈:从栈顶到栈底严格单调递减 题目： ​ 柱状图中最大的矩形(LeetCode_84) 解析： ​ 特例： - 对于这个题，如果从左到右，矩形的高度依次递增（可以不是严格递增），那么我们求解方法为： - 从右到左依次计算各矩形高度，同时乘以该高度为矩形，宽为数组长度减去当前矩形下标（数组下标从0开始计算），最后比较谁大就行了 ​ 正常情况： 但是正常情况下，后一个矩形的高度不一定比前一个矩形高度小，也就是说，就是因为这个矮高度矩形的加入，限制了我们之前矩形的高度。那么之前矩形的高度对于以后的统计就没什么用了，这个时候，我们把矮矩形添加进来之前，先计算高矩形的答案，然后删除高矩形。 这其实就是单调栈模型。在单调栈中进出栈时候，我们比较的是矩形的高度，但是栈中维护的是每个矩形的下标，这样我们就可以在弹出栈时候，统计出宽度，同时知道矩形的高度。我们就可以计算出各个矩形的高度了。由于我们所有操作都是在进栈出栈间完成，所以时间复杂度为O(n). 注意：我们数组的最后个元素进栈后，由于后面没有元素了，所以无法和其他元素进行比较，也就无法出栈，所以我们需要在数组最后添加一个元素，该元素为无穷大，或者无穷小。具体情况看是单调递增还是单调递减栈。如果是单调递减栈，数组最后添加一个无穷小，如果是单调递增栈，数组最后添加一个无穷大元素 单调栈应用 1.最基础的应用就是给定一组数，针对每个数，寻找它和它右边第一个比它大的数之间有多少个数。（小牛向右看） 2.给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列的长度最大。（柱状图中的最大矩形） 3.给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列所有元素和最大。题目 题解 单调递减栈伪代码 所以进栈出栈都是操作元素下标，然后我们可以通过元素下标获取元素 a 为原始数组 a = a+[float('-inf')] stack = [] res = 0 for i in range(len(a)): if (栈为空，或者入栈元素a[i]大于栈顶元素stack[-1]): 入栈 else: while (栈不为空，或者栈顶元素大于等于入栈元素): tmp = stack.pop() 栈元素出栈 res = ... 在这进行res结果更新 stack.append(i) 入栈刚才那个元素 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 19:30:37 "},"单调栈/柱状图中最大的矩形_LeetCode_84.html":{"url":"单调栈/柱状图中最大的矩形_LeetCode_84.html","title":"柱状图中最大的矩形_LeetCode_84","keywords":"","body":"柱状图中最大的矩形(LeetCode_84) 1.题目 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 输入: [2,1,5,6,2,3] 输出: 10 2.分析 暴力法 首先，要想找到第 i 位置最大面积是什么？ 是以i 为中心，向左找第一个小于 heights[i] 的位置 left_i；向右找第一个小于于 heights[i] 的位置 right_i，即最大面积为 heights[i] * (right_i - left_i -1)，如下图所示： 所以，我们的问题就变成如何找 right_i 和 left_i？ 最简单的思路就是，就是暴力法，直接分别在 i 左右移动。 单调栈 ​ 我们要求每一个矩形高度，左边和右边第一个小于该矩形高度的下标。 首先明确，是小于，所以用单调递减栈。 求左边，右边两边的下标，所以要在原始数组左右各添加一个无穷小（或者原始数组中的最小值） 分治法 最大矩形区域在不包含选定柱子的左半区域当中。 最大矩形区域在不包含选定柱子的右半区域当中。 最大矩形区域包含选定柱子的区域。 3.代码 暴力法 class Solution(object): def largestRectangleArea(self, heights): n = len(heights) res = 0 for i in range(n): width = 0 h = heights[i] low = i-1 while low>=0 and heights[low]>=h: low -= 1 high = i+1 while high=h: high += 1 width = high-low-1 res = max(res,width * h) return res 暴力法 class Solution: def largestRectangleArea(self, heights: List[int]) -> int: res = 0 n = len(heights) for i in range(n): left_i = i right_i = i while left_i >= 0 and heights[left_i] >= heights[i]: left_i -= 1 while right_i = heights[i]: right_i += 1 res = max(res, (right_i - left_i - 1) * heights[i]) return res 单调递减栈 class Solution: def largestRectangleArea(self, heights: List[int]) -> int: res = 0 n = len(heights) stack = [] # 单调递减栈，原始数组右边添加一个最小值，是为了让栈内元素全部出栈 # 单调递增栈，原始数组右边添加一个最大值，是为了让栈内元素全部出栈 heights = [0]+heights+[0] for i in range(len(heights)): if not stack or heights[i]>heights[stack[-1]]: stack.append(i) else: while stack and heights[stack[-1]]>=heights[i]: # 每弹出一个元素，就计算比当前弹出元素小的元素有多少个 tmp = stack.pop() if stack: res = max(res, (i-stack[-1]-1)*heights[tmp]) else: # 高度为0的矩形，即heights[0] pass stack.append(i) return res 单调递减栈（简写） class Solution: def largestRectangleArea(self, heights: List[int]) -> int: stack = [] heights = [0] + heights + [0] res = 0 for i in range(len(heights)): #print(stack) while stack and heights[stack[-1]] > heights[i]: tmp = stack.pop() res = max(res, (i - stack[-1] - 1) * heights[tmp]) stack.append(i) return res 分治法 class Solution: def largestRectangleArea(self, heights: List[int]) -> int: n = len(heights) if n == 1: return heights[0]*1 if n == 0: return 0 mid = n//2 left = heights[:mid] right = heights[mid:] left_area = self.largestRectangleArea(left) right_area = self.largestRectangleArea(right) if left[-1]!=right[0]: if left[-1]>right[0]: h = left[-1] low = mid-1-1 while low>=0 and left[low]>=h: low -=1 mid_area = (mid-low-1)*h h = right[0] high = mid+1 low = mid-1-1 while low>=0 and left[low]>=h: low -=1 high = mid+1 while high=h: high +=1 mid_area = max((high-low-1)*h,mid_area) else: h = right[0] high = mid+1 while high=h: high +=1 mid_area = (high-mid)*h h = left[-1] high = mid+1 low = mid-1-1 while low>=0 and left[low]>=h: low -=1 high = mid+1 while high=h: high +=1 mid_area = max((high-low-1)*h,mid_area) else: h = left[-1] low = mid-1-1 while low>=0 and left[low]>=h: low -=1 high = mid+1 while high=h: high +=1 mid_area = (high-low-1)*h return max(left_area,right_area,mid_area) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 20:52:57 "},"单调栈/小牛向右看_POJ_3250.html":{"url":"单调栈/小牛向右看_POJ_3250.html","title":"小牛向右看_POJ_3250","keywords":"","body":"POJ 3250 1.题目 有一群牛站成一排，每头牛都是面朝右的，每头牛可以看到他右边身高比他小的牛。给出每头牛的身高，要求每头牛能看到的牛的总数。 2.分析 求每个数和它右边第一个比它大的数之间的数的个数，分别求出后相加即可。 暴力法 ​ 双重循环遍历，时间复杂度为O(n^2)， 单调栈 - 用单调递增栈 原始数组右边添加float('inf') 时间复杂度为O(n)。 3.代码 单调栈 def func(arr): if not arr:return 0 arr = arr+[float('inf')] res = 0 stack = [] for i in range(len(arr)): if not stack or arr[i]=arr[stack[-1]]: tmp = stack.pop() res += (i-tmp-1) stack.append(i) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 14:58:19 "},"单调栈/最大矩形_LeetCode_85.html":{"url":"单调栈/最大矩形_LeetCode_85.html","title":"最大矩形_LeetCode_85","keywords":"","body":"最大矩形(LeetCode_85) 1.题目 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例: 输入: [ [\"1\",\"0\",\"1\",\"0\",\"0\"], [\"1\",\"0\",\"1\",\"1\",\"1\"], [\"1\",\"1\",\"1\",\"1\",\"1\"], [\"1\",\"0\",\"0\",\"1\",\"0\"] ] 输出: 6 2.分析 参考柱状图中最大的矩形(LeetCode_84) 对每一行进行应用单调递减栈 动态规划 参考接雨水 未写代码 用height_j记录第i行为底,第j列高度是多少. 用left_j记录第i行为底, 第j列左边第一个小于height_j[j]的位置 用right_j记录第i行为底, 第j列右边第一个小于height_j[j]的位置 ​ 3.代码 先计算出矩形高度矩阵 class Solution: def maximalRectangle(self, matrix: List[List[str]]) -> int: if not matrix or not matrix[0]: return 0 res = 0 arr = [] n,m = len(matrix),len(matrix[0]) for i in range(n): tmp_arr =[] for j in range(m): k = i tmp = 0 while k>=0 and matrix[k][j]==\"1\": k -= 1 tmp += 1 tmp_arr.append(tmp) arr.append(tmp_arr) # for i in arr: # print(i) # print(arr[2]) import copy res = 0 for i in range(n): arr_ = [0]+copy.deepcopy(arr[i][:])+[0] # print(arr_) stack = [] for j in range(m+2): if not stack or arr_[j]>arr_[stack[-1]]: stack.append(j) else: while stack and arr_[j] 矩形高度矩阵，然后对每一行应用单调栈 上面代码的17，18行的输出 for i in arr: print(i) [1, 0, 1, 0, 0] [2, 0, 2, 1, 1] [3, 1, 3, 2, 2] [4, 0, 0, 3, 0] 计算一行矩形的高度就用一次单调栈 class Solution: def maximalRectangle(self, matrix: List[List[str]]) -> int: if not matrix or not matrix[0]: return 0 res = 0 arr = [] n,m = len(matrix),len(matrix[0]) for i in range(n): tmp_arr =[] for j in range(m): k = i tmp = 0 while k>=0 and matrix[k][j]==\"1\": k -= 1 tmp += 1 tmp_arr.append(tmp) arr_ = [0]+tmp_arr[:]+[0] # print(arr_) stack = [] for j in range(m+2): if not stack or arr_[j]>arr_[stack[-1]]: stack.append(j) else: while stack and arr_[j] 计算完一行中一个元素，就应用单调栈 class Solution: def maximalRectangle(self, matrix: List[List[str]]) -> int: if not matrix or not matrix[0]: return 0 res = 0 arr = [] n,m = len(matrix),len(matrix[0]) for i in range(n): heights =[0]*(m+2) stack = [] for j in range(m+2): k = i tmp = 0 while 1=0 and matrix[k][j-1]==\"1\": k -= 1 tmp += 1 heights[j] = tmp while stack and heights[j] 最优方法 class Solution: def maximalRectangle(self, matrix: List[List[str]]) -> int: if not matrix or not matrix[0]: return 0 n,m = len(matrix),len(matrix[0]) heights = [0]*(m+2) res = 0 for i in range(n): stack = [] for j in range(m+2): # 本来是 0 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:15:34 "},"单调栈/接雨水_LeetCode_42.html":{"url":"单调栈/接雨水_LeetCode_42.html","title":"接雨水_LeetCode_42","keywords":"","body":"接雨水(LeetCode_42) 1.题目 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 2.分析 这道题真正难点在于: 在一个位置能容下的雨水量等于它左右两边(并不要求最近的最高)柱子最大高度的最小值减去它的高度.比如下图所示, 位置i能容下雨水量:min(3,1) - 0 = 1 所以,问题就变成了: 如何找所有位置的左右两边的柱子的最大值? 单调栈 找最高点，然后从左右两边遍历到中间 动态规划 不用动态规划 3.代码 单调递增栈: ==注意：==因为左边和右边对于接雨水没有用，所以第一个元素的左边我们不需要加float('inf') ,最后个元素也不需要float('inf') class Solution: def trap(self, height: List[int]) -> int: # height = [float('inf')] + height[:] + [float('inf')] n = len(height) res = 0 stack = [] for i in range(n): while stack and height[i]>height[stack[-1]]: tmp = stack.pop() if not stack: break res += (min(height[stack[-1]],height[i])-height[tmp]) * (i-stack[-1] - 1) # print(res) stack.append(i) return res 单调递增栈 class Solution: def trap(self, height: List[int]) -> int: # height = [float('inf')] + height[:] + [float('inf')] n = len(height) res = 0 stack = [] for i in range(n): if not stack or height[i]=height[stack[-1]]: tmp = stack.pop() if stack: res += (min(height[stack[-1]],height[i])-height[tmp]) * (i-stack[-1]-1) else: # 左右两边界不能装水，所以我们不需要 height = [float('inf')] + height[:] + [float('inf')] pass stack.append(i) return res 找最高点，然后从左右两边遍历到中间 # 找到最高点,然后从左右两边遍历到中间 class Solution: def trap(self, height: List[int]) -> int: if len(height) == 1:return 0 res = 0 high_id = 0 high_num = height[0] # 找到最高点 n = len(height) for i in range(1,n): if height[i]>high_num: high_id = i high_num = height[i] # print(high_id) # print(high_num) # 从左边往最高点遍历 tmp = height[0] for i in range(0,high_id): if height[i] > tmp: tmp = height[i] else: res += (tmp-height[i]) # 从右边往最高点遍历 tmp = height[-1] for j in range(n-1,high_id,-1): if height[j] > tmp: tmp = height[j] else: res += (tmp-height[j]) return res 动态规划 class Solution: def trap(self, height: List[int]) -> int: n = len(height) if n height[i]: res += (tmp-height[i]) return res 不用动态规划 class Solution: def trap(self, height: List[int]) -> int: n = len(height) if n left[-1]: left.append(height[i]) else: left.append(left[-1]) right = [height[-1]] for j in range(n-1-1,-1,-1): if height[j] > right[0]: right.insert(0,height[j]) else: right.insert(0,right[0]) print(left) print(right) # 数组的端点，不可能盛水，所以跳过，不用遍历 for i in range(1,n-1): tmp = min(left[i], right[i]) # 当前柱子高度比左右两边都高，则该处不能盛水，跳过 if tmp>height[i]: res += (tmp-height[i]) return res 测试用例 输入：[0,1,0,2,1,0,1,3,2,1,2,1] stdout: [0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3] [3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1] 输出：6 预期结果：6 不用动态规划（...） class Solution: def trap(self, height: List[int]) -> int: n = len(height) if n == 1:return 0 res = 0 # 左右两边不可能盛水，所以跳过，不遍历 for i in range(1,n-1): left = 0 for j in range(0,i): if height[j]>left: left = height[j] right = 0 for j in range(i+1,n): if height[j]>right: right = height[j] tmp = min(right,left) if tmp>height[i]: res += (tmp-height[i]) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:15:10 "},"字符串/":{"url":"字符串/","title":"字符串","keywords":"","body":"字符串 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 22:00:38 "},"字符串/验证回文字符串.html":{"url":"字符串/验证回文字符串.html","title":"验证回文字符串","keywords":"","body":"验证回文字符串 1.题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: \"A man, a plan, a canal: Panama\" 输出: true 示例 2: 输入: \"race a car\" 输出: false 2.分析 可以利用对撞指针 Python isalnum() 方法检测字符串是否由字母和数字组成。 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False #!/usr/bin/python # -*- coding: UTF-8 -*- str = \"this2009\"; # 字符中没有空格 print str.isalnum(); str = \"this is string example....wow!!!\"; print str.isalnum(); 输出 True False Python isalpha() 方法检测字符串是否只由字母组成。 如果字符串至少有一个字符并且所有字符都是字母则返回 True,否则返回 False #!/usr/bin/python str = \"this\"; # No space & digit in this string print str.isalpha(); str = \"this is string example....wow!!!\"; print str.isalpha(); 输出 True False ​ 3.代码 def isPalindrome(self, s: str) -> bool: s = s.lower().replace(' ','') print(s) s = ''.join(list(filter(str.isalnum,s))) # 前三句话可以变成这样 # s = ''.join(filter(str.isalnum,s)).lower() print(s) n = len(s) mid = len(s) // 2 for i in range(mid): if s[i] != s[n-i-1]: return False return True if len(s) == 1: return True 指针对撞法 def isPalindrome(self, s: str) -> bool: s = [i for i in s if i.isalnum()] n = len(s) for i in range(n//2): if s[i].lower() != s[n-i-1].lower(): return False return True 简洁方式 def isPalindrome(self, s): s_filter = ''.join(filter(str.isalnum, s)).lower() return s_filter[::-1] == s_filter 指针对撞法 def isPalindrome(self, s: str) -> bool: l, r = 0, len(s)-1 while l Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 18:35:10 "},"字符串/实现 Trie 前缀树 Leetcode 208.html":{"url":"字符串/实现 Trie 前缀树 Leetcode 208.html","title":"实现 Trie (前缀树)_Leetcode 208","keywords":"","body":"实现 Trie (前缀树)(Leetcode 208) 1.题目 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // 返回 true trie.search(\"app\"); // 返回 false trie.startsWith(\"app\"); // 返回 true trie.insert(\"app\"); trie.search(\"app\"); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 2.分析 ​ trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。” 总体来讲，前缀树的构造过程，通过不断插入新的字符串来丰富这棵26叉树。强调注意这里是26叉树，因为每一个英文字符串中下一个字母都只能是a-z中的一种可能。 前缀树的功能很强大，可以做文本词频统计，例如我们在搜索框中的搜索提示，就可以利用前缀树实现。因此，前缀树基本的操作是字符串的插入，搜索，删除，查找前缀等。 apple:{'a': {'p': {'p': {'l': {'e': {'end': True}}}}}} #第一次insert，最后一个'e'存在结束'end' app: {'a': {'p': {'p': {'l': {'e': {'end': True}}, 'end': True}}}}#第二次insert，第二个'p'存在结束'end' 3.代码 法一 class TrieNode(object): def __init__(self): self.nodes = [None]*26 self.last = False class Trie: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.root = TrieNode() def insert(self, word: str) -> None: \"\"\" Inserts a word into the trie. \"\"\" tree = self.root for i in word: if tree.nodes[ord(i) - ord('a')] == None: tree.nodes[ord(i)-ord('a')] = TrieNode() tree = tree.nodes[ord(i)-ord('a')] tree.last = True def search(self, word: str) -> bool: \"\"\" Returns if the word is in the trie. \"\"\" tree = self.root for i in word: if tree.nodes[ord(i)-ord('a')]==None: return False tree = tree.nodes[ord(i)-ord('a')] return tree.last def startsWith(self, prefix: str) -> bool: \"\"\" Returns if there is any word in the trie that starts with the given prefix. \"\"\" tree = self.root for i in prefix: if tree.nodes[ord(i)-ord('a')] == None: return False tree = tree.nodes[ord(i)-ord('a')] return True # Your Trie object will be instantiated and called as such: # obj = Trie() # obj.insert(word) # param_2 = obj.search(word) # param_3 = obj.startsWith(prefix) 法2(推荐) class Trie(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.root = {} def insert(self, word): \"\"\" Inserts a word into the trie. :type word: str :rtype: None \"\"\" node = self.root for char in word: # 没有就新建{}，有就利用char对应的{} node = node.setdefault(char, {}) node[\"end\"] = True ==================================================== 等价 for char in word: if char not in node: node[char] = {} node['end'] = True ========================================================================= def search(self, word): \"\"\" Returns if the word is in the trie. :type word: str :rtype: bool \"\"\" node = self.root for char in word: if char not in node: return False node = node[char] return \"end\" in node def startsWith(self, prefix): \"\"\" Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool \"\"\" node = self.root for char in prefix: if char not in node: return False node = node[char] return True Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-10 22:49:16 "},"字符串/添加与搜索单词 - 数据结构设计 LeetCode 211.html":{"url":"字符串/添加与搜索单词 - 数据结构设计 LeetCode 211.html","title":"添加与搜索单词 - 数据结构设计 LeetCode 211)(前缀树","keywords":"","body":"添加与搜索单词 - 数据结构设计(LeetCode 211) 1.题目 设计一个支持以下两种操作的数据结构： void addWord(word) bool search(word) search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。 示例: addWord(\"bad\") addWord(\"dad\") addWord(\"mad\") search(\"pad\") -> false search(\"bad\") -> true search(\".ad\") -> true search(\"b..\") -> true 说明: 你可以假设所有单词都是由小写字母 a-z 组成的。 2.分析 3.代码 python代码 class WordDictionary: def __init__(self): self.root = {} def addWord(self, word: str) -> None: tree = self.root for i in word: tree = tree.setdefault(i,{}) tree['end'] = True def search(self, word: str) -> bool: return self.dfs(word,self.root) def dfs(self, word, root): if len(word) == 0: return 'end' in root if root == None: return False for i in word: if i!='.': if i not in root: return False # 不要忘记写return ，只写self...没有return，等于空了吹 return self.dfs(word[1:],root[i]) else: for ele in root.keys():# 可以不用keys,直接tree # 这儿一定要注意，排除ele == ‘end’，这种情况，因为它没有对应一个字典，而是存储了False和True if ele != 'end' and self.dfs(word[1:],root[ele]): return True return False C++ class WordDictionary: def __init__(self): self.root = {'end':False} def addWord(self, word: str) -> None: tree = self.root for i in word: tree = tree.setdefault(i,{'end':False}) tree['end'] = True # for i in word: # if i not in tree: # tree[i] = {'isend':False} # else: # tree = tree[i] # tree['isend'] = True def search(self, word: str) -> bool: tree = self.root res = False for index,value in enumerate(word): if value not in tree: return False if (index List[str]: res = [] tree = WordDictionary() for word in words: tree.addWord(word) for word in words: if tree.search(word): # print(word) res.append(word) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:24 "},"字符串/字符串的反转.html":{"url":"字符串/字符串的反转.html","title":"字符串的反转","keywords":"","body":"字符串的反转 1.题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2： 输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 2.分析 3.代码 def reverseString(self, s: List[str]) -> None: \"\"\" Do not return anything, modify s in-place instead. \"\"\" # s.reverse() # 自己写 # k = len(s) # for i,key in enumerate(s): # if i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:53 "},"字符串/单词的反转.html":{"url":"字符串/单词的反转.html","title":"单词的反转","keywords":"","body":"单词的反转 1.题目 'abc as'--------------->>>>>>>'as abc' 2.分析 两次反转 3.代码 def func(s, start, end): s_len = len(s) i, j = start, end while i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:28 "},"字符串/判断是不是换位字符串.html":{"url":"字符串/判断是不是换位字符串.html","title":"判断是不是换位字符串","keywords":"","body":"判断是不是换位字符串 1.题目 'aaad'和’'daaa'是换位字符串 2.分析 3.代码 def func(s1, s2): bag = [0]*256 for i in s1: bag[ord(i)] += 1 for j in s2: bag[ord(j)] -= 1 for k in bag: if k != 0: print('不是换位字符串') return print('是换位字符串') func('addabas','aabdda') Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:39 "},"字符串/两个字符串的最长公共子串.html":{"url":"字符串/两个字符串的最长公共子串.html","title":"两个字符串的最长公共子串","keywords":"","body":"两个字符串的最长公共子串 1.题目 2.分析 $mat[i][j]$ 表示 $s1[某, i-1],s2[ 某 , j - 1 ] $的最长公共子串的长度 3.代码 代码1 def findMaxSub(s1, s2): s1_len = len(s1) s2_len = len(s2) max_len = 0 max_id = 0 mat = [[0]*(s2_len+1) for _ in range(s1_len+1)] for i in range(1,s1_len+1): for j in range(1,s2_len+1): if s1[i-1] == s2[j-1]: mat[i][j] = mat[i-1][j-1]+1 if mat[i][j] > max_len: max_len = mat[i][j] max_id = i else: mat[i][j] = 0 max_str = s1[max_id-max_len:max_id] print(max_str,max_len) findMaxSub('abccade', 'dgcadde') 代码2 def findMaxSub(s1, s2): s1_len = len(s1) s2_len = len(s2) max_len = 0 max_id = 0 mat = [[0]*(s2_len+1) for _ in range(s1_len+1)] for i in range(1,s1_len+1): for j in range(1,s2_len+1): mat[i][j] = mat[i-1][j-1]+1 if s1[i-1] == s2[j-1] else 0 if mat[i][j] > max_len: max_len = mat[i][j] max_id = i max_str = s1[max_id-max_len:max_id] print(max_str,max_len) findMaxSub('abcdcdabccade', 'dgcadabcdcdde') Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-21 16:16:11 "},"字符串/字符串转换整数 atoi.html":{"url":"字符串/字符串转换整数 atoi.html","title":"字符串转换整数 _atoi","keywords":"","body":"字符串转换整数 (atoi) 示例 1: 输入: \"42\" 输出: 42 示例 2: 输入: \" -42\" 输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: \"4193 with words\" 输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4: 输入: \"words and 987\" 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: \"-91283472332\" 输出: -2147483648 解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 2.分析 草泥马，LeetCode 3.代码 def myAtoi(self, s): s = s.lstrip().split(\" \",1)[0] length = len(s) if length == 0 or s[0] not in '0123456789+-': return 0 index = 1 # 跳过第一个字符，因为第一个字符有可能是‘+-’ # 之所以用s[index].isdigit(),是因为有可能这种情况，‘0012a42’ # 忍不住想吐槽LeetCode，日你妈，题目说明不完善，操你大爷的！！！！ while index Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:57 "},"字符串/无重复字符的最长子串.html":{"url":"字符串/无重复字符的最长子串.html","title":"无重复字符的最长子串","keywords":"","body":"无重复字符的最长子串 1.题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 2.分析 3.代码1 class Solution: def lengthOfLongestSubstring(self, s: 'str') -> 'int': print(s) res = 0 start = 0 bag = {} for index, value in enumerate(s): if value in bag and start 代码2(理解版) class Solution: def lengthOfLongestSubstring(self, s: 'str') -> 'int': res_count = 0 # 最大结果 res_str = '' # 最长字符串 for i in range(len(s)): # 循环这么多次 max_str = '' count = 0 for j in s[i:]: if j not in max_str: count += 1 max_str += j if count > res_count: res_count = count res_str = max_str else: break return res_count Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:59 "},"字符串/最长公共前缀 腾讯.html":{"url":"字符串/最长公共前缀 腾讯.html","title":"最长公共前缀（腾讯）","keywords":"","body":"最长公共前缀（腾讯） 1.题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 2.分析 3.代码 def longestCommonPrefix(self, strs: 'List[str]') -> 'str': res = '' if len(strs) == 0: return res if len(strs) == 1: return strs[0] for i in zip(*strs):#zip()函数用于将可迭代对象作为参数，将对象中对应的元素打包成一个个元 # 组，然后返回由这些元组组成的列表 if len(set(i)) == 1:# 利用集合创建一个无序但不重复（重要）的元素集，可以判断不同字符串 # 同一位置是否是相同字母，如果是，加入该字母，否.... res += i[0] else: return res return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:00 "},"字符串/判断一个串是不是另一个串的子串.html":{"url":"字符串/判断一个串是不是另一个串的子串.html","title":"判断一个串是不是另一个串的子串","keywords":"","body":"判断一个串是不是另一个串的子串 1.题目 判断一个字符串是不是另一个字符串的子串，如 s1 s2 result 'abc' 'abcd' True 'ad' 'ssd' False 'fs' 'fsffsf' True 2.分析 3.代码 # 判断s1是不是s2的子串 def substr(s1, s2): s1_len = len(s1) index = 0 for i in range(len(s2)): # print(i) if s2[i] == s1[index]: index += 1 if index == s1_len: print('True') return # 如果从某一个字符开始，两串对应字符不相等，得重新计数 else: index = 0 if s2[i] == s1[index]: index += 1 print(\"False\") s1 = 'abcdfd' s2 = 'aabcsssdfddf' substr(s1, s2) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:39 "},"字符串/判断一个序列是不是另一个字符串的子序列.html":{"url":"字符串/判断一个序列是不是另一个字符串的子序列.html","title":"判断一个序列是不是另一个字符串的子序列","keywords":"","body":"判断一个序列是不是另一个字符串的子序列 1.题目 判断一个串s1是不是另一个串s2的子序列， - 如s1='a'，s2 = 'abc',则s1是s2的子序列 ,返回True - 如s1='ac'，s2 = 'abc',则s1是s2的子序列, 返回True - 如s1='abc'，s2 = 'abc',则s1是s2的子序列, 返回True - 如s1='abc'，s2 = 'abd',则s1不是s2的子序列, 返回False - 如s1='ad'，s2 = 'abc',则s1不是s2的子序列, 返回False 2.分析 我们可以观察发现，如果 两个串长度相等，内容相同，则s1是s2 的子序列， 如果两个串长度不相等，则s1要想成为s2的子序列，则我们可以 以 s2为基准，依次取出s2的字符，判断与s1的字符相等不，相等 res加1，最后统计结果看 是否res ==len(s1) 3.代码 def subseq(s1,s2): index = 0; if s1 == s2: return True for s in s2: if(index Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:39 "},"字符串/旋转字符串 LeetCode 796.html":{"url":"字符串/旋转字符串 LeetCode 796.html","title":"旋转字符串__LeetCode796","keywords":"","body":"旋转字符串（LeetCode796） 1.题目 给定两个字符串, A 和 B。 A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。如果在若干次旋转操作之后，A 能变成B，那么返回True。 示例 1: 输入: A = 'abcde', B = 'cdeab' 输出: true 示例 2: 输入: A = 'abcde', B = 'abced' 输出: false 注意： A 和 B 长度不超过 100。 2.分析 3.代码 3.1代码1 def rotateString(self, A: str, B: str) -> bool: if len(A) != len(B): return False if not A and not B: return True str_all = A*2 return self.substr(B, str_all) # 判断一个串是不是另一个串的子串 def substr(self, s1, s2): s1_len = len(s1) s2_len = len(s2) index = 0 for i in range(s2_len): if s2[i] == s1[index]: index += 1 if index == s1_len: return True else: index = 0 if s2[i] == s1[index]: index += 1 return False 3.2代码2 def rotateString(self, A: str, B: str) -> bool: if len(A) != len(B): return False if not A and not B: return True return B in A*2 3.3代码3 def rotateString(self, A: str, B: str) -> bool: if len(A) != len(B): return False if not A and not B: return True for i in range(0,len(A)): if A == B: return True A = A[1:]+A[0] return False Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:44:13 "},"字符串/字符串相乘 LeetCode 43.html":{"url":"字符串/字符串相乘 LeetCode 43.html","title":"字符串相乘__LeetCode 43","keywords":"","body":"字符串相乘(LeetCode 43) 1.题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 输入: num1 = \"2\", num2 = \"3\" 输出: \"6\" 示例 2: 输入: num1 = \"123\", num2 = \"456\" 输出: \"56088\" 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 2.分析 对于这个问题，如果你注意到下面的这个规律话就非常简单。 首先要说明的是 我们是按照从左向右的顺序存储的数字。我们注意到对于index:i和index:j相乘的话，结果在index:i+j和index:i+j+1上。 3.代码 代码1 def multiply(self, num1: str, num2: str) -> str: num1_len = len(num1) num2_len = len(num2) res = [0] * (num1_len + num2_len) for i in range(num1_len-1,-1,-1): for j in range(num2_len-1,-1,-1): # 从右向左，所以res[i+j+1]我们可以获取得到 tmp = int(num1[i]) * int(num2[j]) + int(res[i+j+1]) res[i+j+1] = tmp%10 res[i+j] = res[i+j] + tmp//10 res = list(map(str, res)) # print(res) for i in range(num1_len+num2_len): if res[i]!='0': return ''.join(res[i:]) return '0' def multiply(self, num1: str, num2: str) -> str: num1_len = len(num1) num2_len = len(num2) res = [0] *(num1_len+num2_len) for i in range(num1_len-1,-1,-1): for j in range(num2_len-1,-1,-1): tmp = int(num1[i]) * int(num2[j]) + res[i+j+1] res[i+j+1] = tmp % 10 res[i+j] += tmp//10 for i in range(num1_len+num2_len): if res[i] != 0: return ''.join(map(str,res[i:])) return '0' 代码2（大神版） def multiply(self, num1, num2): res = 0 for i in range(1,len(num1)+1): for j in range(1, len(num2)+1): res += int(num1[-i]) * int(num2[-j]) *10**(i+j-2) return str(res) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 01:07:02 "},"字符串/反转字符串中的单词 III.html":{"url":"字符串/反转字符串中的单词 III.html","title":"反转字符串中的单词 III","keywords":"","body":"反转字符串中的单词 III 1.题目 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 输入: \"Let's take LeetCode contest\" 输出: \"s'teL ekat edoCteeL tsetnoc\" 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 2.分析 3.代码 代码1 def reverseWords(self, s): if s == '': return '' s = s.split() res = [] res = ' '.join(i[::-1] for i in s) # print(res) return res 代码2 def reverseWords(self, s: str) -> str: print(s.split()[::-1]) s = list(s) start = 0 # self.func(s, 0 , len(s)-1) for i in range(len(s)-1): if s[i] == ' ': self.func(s, start, i-1) start = i+1 self.func(s, start, len(s)-1) res = ''.join(s) # print(res) return res def func(self, s, b, e): # 需要逆置的子串的头尾序号 # b:begin e:end while b Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:43:23 "},"字符串/存在重复元素.html":{"url":"字符串/存在重复元素.html","title":"存在重复元素","keywords":"","body":"存在重复元素 1.题目 给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 2.分析 3.代码 counter def containsDuplicate(self, nums): from collections import Counter nums_count = Counter(nums) for i in nums_count.values(): if i >= 2: return True return False return not len(nums) == len(set(nums)) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:57 "},"字符串/字符串相加_LeetCode_415.html":{"url":"字符串/字符串相加_LeetCode_415.html","title":"字符串相加_LeetCode_415","keywords":"","body":"字符串相加(LeetCode_415) 1.题目 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 2.分析 法一：转化为列表 法二：不转化为列表 3.代码 法一 def addStrings(self, num1: str, num2: str) -> str: res = '' tmp = 0 num1 = list(num1) num2 = list(num2) while num1 or num2 or tmp: i = num1.pop() if num1 else 0 j = num2.pop() if num2 else 0 # s:商 y:余数 s,y = divmod(int(i)+int(j)+tmp,10) res = str(y) + res tmp = s return res 法二 res = '' tmp = 0 num1_len = len(num1) num2_len = len(num2) while num1_len>0 or num2_len>0 or tmp: num1_len -= 1 num2_len -= 1 i = num1[num1_len] if num1_len>=0 else 0 j = num2[num2_len] if num2_len>=0 else 0 s,y = divmod(int(i)+int(j)+tmp, 10) res = str(y) + res tmp = s return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-15 17:09:14 "},"字符串/第一个只出现一次的字符.html":{"url":"字符串/第一个只出现一次的字符.html","title":"第一个只出现一次的字符","keywords":"","body":"在一个字符串(0 说一下解题思路哈，其实主要还是hash，利用每个字母的ASCII码作hash来作为数组的index。首先用一个58长度的数组来存储每个字母出现的次数，为什么是58呢，主要是由于A-Z对应的ASCII码为65-90，a-z对应的ASCII码值为97-122，而每个字母的index=int(word)-65，比如g=103-65=38，而数组中具体记录的内容是该字母出现的次数，最终遍历一遍字符串，找出第一个数组内容为1的字母就可以了，时间复杂度为O(n) ASCII码中的90-96不是字母 但是为了统一减65来计算 所以要再加上6个长度 不然就要判断是否是小写字母 小写字母要减65再减6 class Solution: def FirstNotRepeatingChar(self, s): # write code here if s == '': return -1 res = [0]*58 n = len(s) for i in s: res[ord(i)-65] += 1 for i in range(n): if res[ord(s[i])-65] == 1: return i 字典法 class Solution: def FirstNotRepeatingChar(self, s): # write code here if s == '': return -1 n = len(s) res = dict() for i in range(n): if s[i] not in res: res[s[i]] = i else: res[s[i]] = -1 for i in range(n): if res[s[i]] != -1: # return res[s[i]] return i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 22:45:08 "},"数组/":{"url":"数组/","title":"数组","keywords":"","body":"数组 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 22:00:38 "},"数组/搜索旋转排序数组.html":{"url":"数组/搜索旋转排序数组.html","title":"搜索旋转排序数组","keywords":"","body":"搜索旋转排序数组 1.题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 2.分析 方法：双指针二分法 思路 1，不管数组如何变化，它总归还是一个有序数组，只是变成了两个升序数组的组合，所以可以使用二分法； 2，双指针，指向头尾，拿着target和数组中间元素nums[mid]比较，分三种情况判断：（1）若相等则直接mid就是答案；（2）如果nums[mid]比头元素大与等于，并且目标值在它和头元素之间，则尾指针变为mid - 1,否则头指针变为mid + 1;（3）如果nums[mid]比头元素小，并且目标值在尾巴元素和中间元素之间，那么头指针就变为mid + 1,否则尾指针变为mid - 1； 3，如果全部没有找到目标值相匹配的元素，或者数组长度为空，就返回-1即可，总之就还是二分法的应用，仔细推敲，分析就可以弄懂！ 左边有序，去左边找 右边有序，去右边找 3.代码 def search(self, nums: List[int], target: int) -> int: if nums == None:return -1 l, r = 0, len(nums)-1 while l = nums[l]: if target >= nums[l] and target nums[mid] and target 优秀的代码 class Solution: def binary_search(self, left, right, nums, target): while left target: right = mid - 1 return False def sub_search(self, left, right, nums, target): if left = nums[left]: #左边是有序的 if target = nums[left]: #target在左边 return self.binary_search(left, mid - 1, nums, target) else: return self.sub_search(mid + 1, right, nums, target) elif nums[mid] nums[mid] and target 'bool': if len(nums) == 0: return False return self.sub_search(0, len(nums) - 1, nums, target) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:58 "},"数组/搜索旋转排序数组 II LeetCode 81.html":{"url":"数组/搜索旋转排序数组 II LeetCode 81.html","title":"搜索旋转排序数组 II_LeetCode 81","keywords":"","body":"搜索旋转排序数组 II(LeetCode 81) 1.题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1: 输入: nums = [2,5,6,0,0,1,2], target = 0 输出: true 示例 2: 输入: nums = [2,5,6,0,0,1,2], target = 3 输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 2.分析 解题思路 这是之前Leetcode 33：搜索旋转排列数组（最详细的解法！！！）问题的延伸。如果使用之前的方法解决这个问题，会出现错误，例如 1 3 1 1 1 丨 | 我们会在[0:2]这个区间查找对应元素，但是这样是错误的，这个区间并不是递增区间。那要怎么做呢？ 一种最简单的思路就是将nums的重复元素去除，然后在使用之前的方法就可以啦。 3.代码 去重代码 def search(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: bool \"\"\" if not nums: return False nums = list(set(nums)) low, high = 0, len(nums) - 1 while low 不去重代码 def search(self, nums: List[int], target: int) -> bool: if nums == None: return False l, r = 0, len(nums)-1 while l 优秀的代码 class Solution: def binary_search(self, left, right, nums, target): while left target: right = mid - 1 return False def sub_search(self, left, right, nums, target): if left = nums[left]: #左边是有序的 if target = nums[left]: #target在左边 return self.binary_search(left, mid - 1, nums, target) else: return self.sub_search(mid + 1, right, nums, target) elif nums[mid] nums[mid] and target 'bool': if len(nums) == 0: return False return self.sub_search(0, len(nums) - 1, nums, target) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:58 "},"数组/合并两个有序数组.html":{"url":"数组/合并两个有序数组.html","title":"合并两个有序数组","keywords":"","body":"合并两个有序数组 1.题目 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 2.分析 3.代码 class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None: \"\"\" Do not return anything, modify nums1 in-place instead. \"\"\" ''' 两个有序数组进行合并,就联想到归并排序。我们既可以从前往后归并，也可以从后往前归并。 但是本题nums1后面留的空间足够，所以我们在nums1尾部进行添加元素，不需要重新开辟数组进行归并。因此我们只能从后向前归并，因为nums2归并到nums1上，如果从前往后归并，那么需要不断调整nums1的值，防止nums1中未归并的值被覆盖丢失，相当复杂。而我们从后往前归并，就不需要这么复杂了。 我们归并的起点为m-1,n-1(因为这是下标表示，所以减一)。归并结果保存位置从 (m+n-1)开始(因为这是下标表示，所以减一)。归并起点和归并结果的位置都是从右向左前进。 第一轮循环合并完后，由于可能nums2指针未走完(n>=0:nums2还有元素比nums1最小元素小)，需要将nums2剩余首部覆盖至nums1首部。nums1指针未走完不需要做任何多余操作，因为覆盖前后相同。 nums1 = 【3,4,5,0,0】 nums2 = 【1,2】 第一个while循环跳出后, nums1 = [3,4,3,4,5] nums2 = [1,2] nums2的下标为 n=1 所以 用while循环将nums2依次添加到nums1 nums1 = 【1,2,5,0,0】 nums2 = 【3,4】 第一个while循环跳出后, nums1 = [1,2,3,4,5] nums2 = [] nums2 的下标为 n=-1 不用第二个循环 ''' # nums1 添加的新值的首下标 cur = m+n-1 n = n-1 m = m-1 while n>=0 and m>=0: if nums1[m]>nums2[n]: nums1[cur] = nums1[m] m -= 1 else: nums1[cur] = nums2[n] n -= 1 cur -= 1 while n>=0: nums1[cur] = nums2[n] n -= 1 cur -= 1 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 16:55:54 "},"数组/旋转数组.html":{"url":"数组/旋转数组.html","title":"旋转数组","keywords":"","body":"旋转数组 1.题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 2.分析 3.代码 代码1 class Solution: def rotate(self, nums: List[int], k: int) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" for i in range(k): x = nums.pop() nums.insert(0,x) 代码2 翻转法，经过三次翻转： 翻转 0 ~ n-1 翻转 0 ~ k-1 翻转 k ~ n-1 空间复杂度 O(1)，时间复杂度 O(n)。 def rotate(self, nums, k): n = len(nums) # 不需要旋转 if n == 0 or n == 1: return k %= n self.func(nums, 0, n-1) self.func(nums, 0, k-1) self.func(nums, k, n-1) def func(self, nums, start, end): while start 左旋 def rotate(self, nums, k): n = len(nums) k = k%n if k == 0: return count = n-k tmp = nums[:] for i in range(n): nums[i] = tmp[(i+count)%n] 右旋 def rotate(self, nums, k): n = len(nums) k = k%n if k == 0: return tmp = nums[:] for i in range(n): nums[(i+k)%n] = tmp[i] pythonic def rotate(self, nums, k): n = len(nums) k = k%n if k == 0: return # 注意：这儿是nums[:],而不是nums nums[:] = nums[n-k:]+nums[0:n-k] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:41:23 "},"数组/寻找旋转排序数组中的最小值 LeetCode 153.html":{"url":"数组/寻找旋转排序数组中的最小值 LeetCode 153.html","title":"寻找旋转排序数组中的最小值 LeetCode 153","keywords":"","body":"寻找旋转排序数组中的最小值（LeetCode 153） 1.题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2] 输出: 1 示例 2: 输入: [4,5,6,7,0,1,2] 输出: 0 2.分析 通过选择数组的特性知道，数组元素先是递增，然后突然下降到最小值，然后再递增。 数组本身没有旋转，是一个有序数组，例如[1,2,3,4] 数组中元素全部相等，例如【1，1，1，1】 数组中大部分元素相同，如【1，0，1，1，1】 通过分析知道，旋转数组可以划分为两个有序数组，前面的数组的每个元素都大于等于后面数组的每个元素，可以用二分法不断缩小查找范围。 如果没有旋转，则第一个元素小于最后个元素，直接返回第一个元素 如果nums[mid] ,则nums[mid]最小 如果nums[mid+1] ,则nums[mid+1]最小 如果nums[mid] ,则最小值在数组左边 如果nums[mid] > nums[left],则最小值在数组右边 如果nums[mid] == nums[right] == nums[left],如【2，2，2，1，2】无法区别时，只能求左右最小值，然后返回左右最小值中最小的 3.代码 def findMin(self, nums: List[int]) -> int: if not nums: return -1 if len(nums) == 1: return nums[0] if nums[0] nums[mid]: return nums[mid] elif nums[mid+1] nums[left]: left = mid+1 else: return min(self.findMin_1(nums, left, mid-1), self.findMin_1(nums, mid+1, right)) 3.2代码2 # 二分法：首先要判断这个有序数组是否旋转了，通过比较第一个和最后一个数的大小，如果第一个数小，则没有旋转，直接返回这个数。如果第一个数大，就要进一步搜索。我们定义left和right两个指针分别指向开头和结尾，还要找到中间那个数，然后和left指的数比较，如果中间的数大，则继续二分查找右半段数组，反之查找左半段。终止条件是当左右两个指针相邻，返回小的那个。 def findMin(self, nums): if not nums: return -1 if len(nums) == 1: return nums[0] # 没有旋转 if nums[0] 3.3代码3 # 二分法：首先要判断这个有序数组是否旋转了，通过比较第一个和最后一个数的大小，如果第一个数小，则没有# # 旋转，直接返回这个数。如果第一个数大，就要进一步搜索。我们定义left和right两个指针分别指向开头和结 # 尾，还要找到中间那个数，然后和left指的数比较，如果中间的数大，则继续二分查找右半段数组，反之查找左半# 段。终止条件是当左右两个指针相邻，返回小的那个。 def findMin(self, nums): if not nums: return -1 if len(nums) == 1: return nums[0] if nums[0] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-14 17:34:24 "},"数组/寻找旋转排序数组中的最小值_含重复元素_LeetCode_154.html":{"url":"数组/寻找旋转排序数组中的最小值_含重复元素_LeetCode_154.html","title":"寻找旋转排序数组中的最小值_含重复元素_LeetCode_154","keywords":"","body":"寻找旋转排序数组中的最小值 II(LeetCode_154) 1.题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 注意数组中可能存在重复的元素。 示例 1： 输入: [1,3,5] 输出: 1 示例 2： 输入: [2,2,2,0,1] 输出: 0 2.分析 3.代码 暴力法 def findMin(self, nums): for i in range(1,len(nums)): if nums[i] def findMin(self, nums): if not nums: return -1 if len(nums) == 1: return nums[0] if nums[0] nums[right]: left = mid+1 else: # 数组中存在重复元素，所以每次只缩小一个查找范围 right -= 1 return nums[left] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 18:03:09 "},"数组/删除排序数组中的重复项.html":{"url":"数组/删除排序数组中的重复项.html","title":"删除排序数组中的重复项","keywords":"","body":"删除排序数组中的重复项 1.题目 2.分析 3.代码 def removeDuplicates(self, nums: List[int]) -> int: nums_len = len(nums) for i in range(nums_len-1, 0 , -1): if nums[i] == nums[i-1]: nums.pop(i) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:37 "},"数组/找出数组中出现次数为奇数次的数 异或法.html":{"url":"数组/找出数组中出现次数为奇数次的数 异或法.html","title":"找出数组中出现次数为奇数次的数 异或法","keywords":"","body":"找出数组中出现次数为奇数次的数（异或法） 1.题目 ​ 数组中有N+2个数，其中N个数出现了偶数次，2个数出现了奇数次（这两个数不相同），请用O（1）的空间复杂度，找出这两个数，注意，不需要找出位置。 2.分析 3.代码 def get2Num(nums): res = 0 for i in nums: res ^= i tmp_res = res # 找出异或结果中其中一位为1的位置 pos = 0 while res & 1 == 0: pos += 1 res >> 1 for i in nums: if (i>>pos)&1 == 1: tmp_res = i ^ tmp_res print(tmp_res) print(tmp_res^res) nums = [2,2,2,2,4,5,6,6] get2Num(nums) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:57 "},"数组/求数组中两个元素的最小距离.html":{"url":"数组/求数组中两个元素的最小距离.html","title":"求数组中两个元素的最小距离","keywords":"","body":"求数组中两个元素的最小距离 1.题目 ​ 给定一个数组，数组中含有重复元素，给定两个数字num1 和num2,求这两个数字在数组中出现的位置的最小距离 2.分析 ​ 哈希法,双指针法 3.代码 3.1哈希法 def minDis(nums, k1, k2): bag = {} min_dis = float('inf') for index, value in enumerate(nums): if value == k1: bag[value] = index print(bag) if k2 in bag: min_dis = min(min_dis, index-bag.get(k2)) elif value == k2: bag[value] = index print(bag) if k1 in bag: min_dis = min(min_dis, index-bag.get(k1)) print(bag) print(min_dis) minDis([4,5,6,4,7,4,6,4,7,8,5,6,4,3,10,8],4,8) 3.2代码2（用while循环） def minDis(nums, k1, k2): min_dis = float('inf') k1_pos = -1 k2_pos = -1 i = 0 while i = 0: min_dis = min(min_dis, i-k2_pos) elif nums[i] == k2: k2_pos = i if k1_pos >= 0: min_dis = min(min_dis, i-k1_pos) i += 1 print(min_dis) minDis([4,5,6,4,7,4,6,4,7,8,5,6,4,3,10,8],4,8) [!NOTE] a = {'3':2,'43':43} a[0] 字典这么取值是错的 应该这样： a = {'3':2,'43':43} a.get('3') Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:41:57 "},"数组/回文数 LeetCode 9.html":{"url":"数组/回文数 LeetCode 9.html","title":"回文数_LeetCode 9","keywords":"","body":"回文数(LeetCode 9) 1.题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 2.分析 整数逆置 3.代码 不用自己写反转 def isPalindrome(self, x: 'int') -> 'bool': x = str(x) new_x = x[::-1] if new_x == x: return True return False 自己写反转判断 def isPalindrome(self, x: 'int') -> 'bool': x = str(x) return self.func(x) def func(self, x): l, r =0, len(x)-1 while l 整数逆置 def isPalindrome(self, x: 'int') -> 'bool': # 如果负数，不是回文数；如果个位数是0（除0这种特殊情况），不是回文数 if x 反转一半数 # 反转一半数 def isPalindrome(self, x: 'int') -> 'bool': if x right_rev: right_rev = right_rev*10 + x%10 x = x//10 # 奇偶情况都考虑 return x==right_rev or x==right_rev//10 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:50 "},"数组/异或操作.html":{"url":"数组/异或操作.html","title":"异或操作","keywords":"","body":"异或操作 1.性质 异或操作满足交换律和结合律 0和一个数异或，等于该数 两数相同，异或，等于0 两数不同，异或，等于其他数 2.1找出只出现一次的元素 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 代码 # 异或解决 def singleNumber(self, nums): a = 0 for num in nums: a = a ^ num return a 2.2不使用额外空间，交换元素 a = a ^ b; b = a ^ b; # a ^ b ^ b = a ^ 0 = a; a = a ^ b; a = a + b b = a - b a = a - b 2.3互换二进制的奇偶位 0x5555 = 101010101010101 0xaaaa = 1010101010101010 a = 6 tmp_1 = (a & 0x5555)> 1 # 取出奇数位 tmp = tmp_1 ^ tmp_2 print(tmp) # 9 2.3找出出现两次的数 def findDup(nums): nums_len = len(nums) i = 0 for j in nums: i ^= j # print(i) j = 1 while j 2.4异或来判断一个二进制数中1的数量是奇数还是偶数 求10100001中1的数量是奇数还是偶数； 答案：1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1,结果为1就是奇数个1，结果为0就是偶数个1； res = 0 for i in nums: res = res ^ i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 12:56:07 "},"数组/除自身以外数组的乘积.html":{"url":"数组/除自身以外数组的乘积.html","title":"除自身以外数组的乘积","keywords":"","body":"除自身以外数组的乘积 1.题目 给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4] 输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 2.分析 前缀积 3.代码 def productExceptSelf(self, nums): nums_len = len(nums) res = [1]*nums_len right = 1 for i in range(1, nums_len): res[i] = res[i-1] * nums[i-1] for i in range(nums_len-1, -1, -1): res[i] = res[i]*right right = right * nums[i] # print(res) return res def productExceptSelf(self, nums): nums_len = len(nums) left = [1]*nums_len right = [1]*nums_len res = [] for i in range(1,nums_len): left[i] = left[i-1] * nums[i-1] right[-(i+1)] = right[-(i+1)+1] * nums[-(i+1)+1] for i in range(nums_len): res.append(left[i]*right[i]) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:25 "},"数组/最大子序和LeetCode 53.html":{"url":"数组/最大子序和LeetCode 53.html","title":"最大子序和LeetCode 53","keywords":"","body":"最大子序和(LeetCode 53) (子数组) 1.题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 2.分析 使用动态规划 F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变 F（i）=max（F（i-1）+array[i] ， array[i]） res：所有子数组的和的最大值 res=max（res，F（i）） 如数组[6, -3, -2, 7, -15, 1, 2, 2] 初始状态： F（0）=6 res=6 i=1： F（1）=max（F（0）-3，-3）=max（6-3，3）=3 res=max（F（1），res）=max（3，6）=6 i=2： F（2）=max（F（1）-2，-2）=max（3-2，-2）=1 res=max（F（2），res）=max（1，6）=6 i=3： F（3）=max（F（2）+7，7）=max（1+7，7）=8 res=max（F（2），res）=max（8，6）=8 i=4： F（4）=max（F（3）-15，-15）=max（8-15，-15）=-7 res=max（F（4），res）=max（-7，8）=8 以此类推 最终res的值为8 3.代码 class Solution(object): def maxSubArray(self, nums): sum = 0 max_sub_sum = nums[0] for num in nums: sum += num if sum > max_sub_sum: max_sub_sum = sum if sum 动态规划 def FindGreatestSumOfSubArray(self, array): # write code here # 动态规划 a_len = len(array) res = array[0] dp = [0]*a_len for i in range(a_len): dp[i] = max(dp[i-1]+array[i], array[i]) res = max(res, dp[i]) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 10:34:50 "},"数组/两数之和 II - 输入无须数组.html":{"url":"数组/两数之和 II - 输入无须数组.html","title":"两数之和 II - 输入无须数组","keywords":"","body":"两数之和 II - 输入无须数组 1.题目 2.分析 3.代码 3.1二分法 class Solution: def binary_search(self, li, left, right, val): while left li[mid][0]: left = mid + 1 else: right = mid - 1 else: return None def twoSum(self, nums, target): new_list = [[num,i] for i,num in enumerate(nums)] new_list.sort() for i in range(len(new_list)): a = new_list[i][0] b = target - a if b > a: j = self.binary_search(new_list, i + 1, len(new_list) - 1, b) else: j = self.binary_search(new_list, 0, i - 1, b) if j: break return [new_list[i][1], new_list[j][1]] ret = Solution() print(ret.twoSum([-1,-3,-2],-5)) 3.2字典法 class Solution: def twoSum(self, nums, target): nums_len = len(nums) for i in range(nums_len): dif = target - nums[i] if dif in nums[:i]: return [nums.index(dif), i] return [] 3.3字典法 class Solution: def twoSum(self, nums, target): bag = {} for index, value in enumerate(nums): dif = target - value if dif in bag: return [index, bag[dif]] return [] 3.4切片法 class Solution: def twoSum(self, nums, target): nums_len = len(nums) for i in range(nums_len): dif = target - nums[i] if dif in nums[:i]: return [nums.index(dif), i] return [] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:29 "},"数组/两数之和 II - 输入有序数组.html":{"url":"数组/两数之和 II - 输入有序数组.html","title":"两数之和 II - 输入有序数组","keywords":"","body":"两数之和 II - 输入有序数组 1.题目 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 2.分析 暴力法， 二分法， 指针对撞法 3.代码 暴力法 class Solution: def twoSum(self, numbers: List[int], target: int) -> List[int]: for i in range(len(numbers)-1): for j in range(i+1,len(numbers)): if numbers[i]+numbers[j] == target: return [i+1,j+1] return [] 二分法 def binary_search(self, li, left, right, val): while left li[mid]: left = mid + 1 else: right = mid - 1 else: return None def twoSum(self, nums, target): for i in range(len(nums)): a = nums[i] b = target - a if b > a: j = self.binary_search(nums, i + 1, len(nums) - 1, b) else: j = self.binary_search(nums, 0, i - 1, b) if j and j!=i: break return [i+1, j+1] 字典法 class Solution: def twoSum(self, numbers: List[int], target: int) -> List[int]: m={} for index,value in enumerate(numbers): if target-value in m: return[m[target-value]+1,index+1] m[value]=index 双指针法（指针对撞法） ==if elif else: 只会走一个== if 3>2: print(111) elif 4>2: print(4444) else: print(6666) 输出：111 if 3>22: print(111) elif 4>2: print(4444) else: print(6666) 输出：444 def twoSum(self, numbers, target): left, right = 0, len(numbers)-1 sum_all = 0 while left target: right -= 1 # continue 可以不加，因为if elif else 只会走一个 elif sum_all Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 09:17:38 "},"数组/反转字符串中的单词 III.html":{"url":"数组/反转字符串中的单词 III.html","title":"反转字符串中的单词 III","keywords":"","body":"反转字符串中的单词 III 1.题目 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 输入: \"Let's take LeetCode contest\" 输出: \"s'teL ekat edoCteeL tsetnoc\" 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 2.分析 3.代码 代码1 def reverseWords(self, s): if s == '': return '' s = s.split() res = [] res = ' '.join(i[::-1] for i in s) # print(res) return res 代码2 def reverseWords(self, s: str) -> str: print(s.split()[::-1]) s = list(s) start = 0 # self.func(s, 0 , len(s)-1) for i in range(len(s)-1): if s[i] == ' ': self.func(s, start, i-1) start = i+1 self.func(s, start, len(s)-1) res = ''.join(s) # print(res) return res def func(self, s, b, e): # 需要逆置的子串的头尾序号 # b:begin e:end while b Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:41 "},"数组/长度最小的子数组.html":{"url":"数组/长度最小的子数组.html","title":"长度最小的子数组","keywords":"","body":"长度最小的子数组 1.题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例: 输入: s = 7, nums = [2,3,1,2,4,3] 输出: 2 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 2.分析 滑动窗口法 3.代码 class Solution: def minSubArrayLen(self, s, nums): sum_all = 0 left, right = 0, 0 nums_len = len(nums) min_len = nums_len+1 while left = s: min_len = min(min_len, right-left) if min_len == nums_len+1: return 0 else: return min_len Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:25 "},"数组/合并区间_LeetCode_56.html":{"url":"数组/合并区间_LeetCode_56.html","title":"合并区间_LeetCode_56","keywords":"","body":"合并区间(LeetCode_56) 1.题目 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 2.分析 ... 3.代码 简化 class Solution: def merge(self, intervals: List[List[int]]) -> List[List[int]]: if not intervals:return [] # arr = sorted(intervals, key=lambda x:(x[0],[x[1]])) # 只需对每个元素第一个位置排序即可，不需要两个位置都排序 arr = sorted(intervals, key=lambda x:x[0]) res = [arr[0]] for i in range(1,len(arr)): if res[-1][1] >= arr[i][0]: res[-1][1] = max(res[-1][1], arr[i][1]) else: res.append([arr[i][0],arr[i][1]]) return res 略显复杂 class Solution: def merge(self, intervals: List[List[int]]) -> List[List[int]]: if not intervals:return [] arr = sorted(intervals, key=lambda x:(x[0],[x[1]])) # print(arr) res = [arr[0]] for i in range(1,len(arr)): if res[-1][1] >= arr[i][0]: tmp = [min(res[-1][0],arr[i][0]),max(res[-1][1],arr[i][1])] res.pop() res.append(tmp) else: res.append([arr[i][0],arr[i][1]]) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 18:03:38 "},"数组/最长连续递增序列_LeetCode_674.html":{"url":"数组/最长连续递增序列_LeetCode_674.html","title":"最长连续递增序列_LeetCode_674","keywords":"","body":"1.题目 给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例 1: 输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2: 输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。 注意：数组长度不会超过10000。 2.分析 要求时间复杂度为O（n） 3.代码 动态规划 class Solution: def findLengthOfLCIS(self, nums: List[int]) -> int: n = len(nums) if nnums[i-1]: dp[i] = dp[i-1]+1 return max(dp) class Solution: def findLengthOfLCIS(self, nums: List[int]) -> int: nums_len = len(nums) if len(nums)nums[i-1]: count += 1 res = max(res, count) else: count = 1 return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 12:06:47 "},"数组/调整数组，奇数在前偶数在后，保持相对顺序.html":{"url":"数组/调整数组，奇数在前偶数在后，保持相对顺序.html","title":"调整数组，奇数在前偶数在后，保持相对顺序","keywords":"","body":"冒泡排序是稳定的 def func(nums): nums_len = len(nums) if nums_len Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 18:18:52 "},"数组/找出数组中2个出现一次的数.html":{"url":"数组/找出数组中2个出现一次的数.html","title":"找出数组中2个出现一次的数","keywords":"","body":"剑指Offer（四十）：数组中只出现一次的数字 二、题目 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 1、思路 大家首先想到的是顺序扫描法，但是这种方法的时间复杂度是O（n^2）。接着大家又会考虑用哈希表的方法，但是空间复杂度不是O（1）。 应该怎么做才能即满足时间复杂度是O（n）又满足空间复杂度是O（1）的要求呢？ 我们可以想一想“异或”运算的一个性质，我们直接举例说明。 举例：{2,4,3,6,3,2,5,5} 这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？ 我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 3.代码 一次遍历法 class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here res = set() for i in array: if i not in res: res.add(i) else: res.remove(i) return list(res) 异或 class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here res = 0 for i in array: res ^= i index = 0 while True: if res&1 ==0: index += 1 res >>= 1 else: break a = 0 b = 0 for i in array: if i>>index&1==1: a ^= i else: b ^= i return [a,b] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 17:49:08 "},"矩阵/":{"url":"矩阵/","title":"矩阵","keywords":"","body":"矩阵 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 22:00:38 "},"矩阵/搜索二维矩阵 LeetCode 74.html":{"url":"矩阵/搜索二维矩阵 LeetCode 74.html","title":"搜索二维矩阵_LeetCode 74","keywords":"","body":"搜索二维矩阵(LeetCode 74) 1.题目 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1: 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 示例 2: 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 输出: false 2.分析 一是变为一维列表，进行二分查找 二是就在愿矩阵上，进行查找，不过起始点，选为左下，或者右上，但是我们不能选择左上角和右下角为起点，假设左上角的数字为1，我们查找数字为7，那么第一次比较7比1大，但是我们无法缩小查询范围（即不能剔除第一行，也不能剔除第一列） 3.代码 二分查找 def searchMatrix(self, matrix: List[List[int]], target: int) -> bool: if len(matrix) == 0 or len(matrix[0]) == 0: return False m = len(matrix) n = len(matrix[0]) left = 0 right = m*n -1 res =[] for i in matrix: # 注意：这儿是将矩阵编程以为列表 res.extend(i) return self.binary_search(res, left, right, target) def binary_search(self,li, left, right, target): while left 在原矩阵上进行查找 def searchMatrix(self, matrix, target): if not matrix:return False m, n = len(matrix), len(matrix[0]) i, j = m-1, 0 # 从左下角开始查找 while i>=0 and j Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-11 19:08:15 "},"矩阵/搜索二维矩阵 II LeetCode 240.html":{"url":"矩阵/搜索二维矩阵 II LeetCode 240.html","title":"搜索二维矩阵 II_LeetCode 240","keywords":"","body":"搜索二维矩阵 II(LeetCode 240) 1.题目 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 2.分析 因为展开成一维列表后也不是有序的，因此，我们就在原矩阵上进行查找，查找的起始点是左下角和右上角 3.代码 def searchMatrix(self, matrix, target): \"\"\"每一行都用二分法计算，但是，如果匹配成功啦，不是返回的下标，而是True :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" if len(matrix) == 0 or len(matrix[0]) == 0: return False m, n = len(matrix)-1,len(matrix[0])-1 i = m j = 0 while (i>=0 and j C++ class Solution { public: bool searchMatrix(vector>& matrix, int target) { / // 不加这个传入为空的判断的话会访问越界 // 只有一句话，可以不加大括号 // if (matrix.empty()) // return 0; //也可以这么判断， int len = matrix.size(); if (len == 0) return 0; int row = matrix.size()-1; int col = matrix[0].size()-1; int j = 0; int i = row; while (i>=0 && j target){ i--; continue; } else if (matrix[i][j] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:57 "},"矩阵/最小路径和 LeetCode 64.html":{"url":"矩阵/最小路径和 LeetCode 64.html","title":"最小路径和_LeetCode 64","keywords":"","body":"最小路径和(LeetCode 64) 1.题目 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 2.分析 ​ (动态规划1)：时间复杂为o(nm)和空间复杂度为o(nm)。典型的动态规划问题，假设当前已经开始计算s[i][j]，那么s[i][j]只可能从s[i-1][j]+grid[i][j]或者s[i][j-1]+grid[i][j]计算得到，也就是s[i][j] = min(s[i-1][j],s[i][j-1])+grid[i][j]。我们需要一个o(nm)额外空间保存已经计算的s[i][j]的值，我们只需要访问一遍数组即可。因此时间复杂度为o(nm)，空间复杂度为o(n*m)。我们需要特殊处理矩阵中第一行和第一列。因为第一行没有s[i-1][j]元素，只有s[i][j-1]元素。第一列没有s[i][j-1]元素，只有s[i-1][j]元素。 3.代码 动态规划1(原地修改)： def minPathSum(self, grid): if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) for i in range(1,n): grid[i][0] = grid[i-1][0] + grid[i][0] for j in range(1,m): grid[0][j] = grid[0][j-1] + grid[0][j] for i in range(1,n): for j in range(1,m): grid[i][j] = min(grid[i-1][j], grid[i][j-1])+grid[i][j] return grid[-1][-1] def minPathSum(self, grid): if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) for i in range(n): for j in range(m): if i==0 and j>0: grid[i][j] = grid[i][j-1] + grid[i][j] elif j==0 and i>0: grid[i][j] = grid[i-1][j] + grid[i][j] elif i>0 and j>0: grid[i][j] = min(grid[i-1][j], grid[i][j-1])+grid[i][j] return grid[-1][-1] (动态规划2)：时间复杂度为o(nm)，空间复杂度为o(m)，此方法需要2m额外空间。当我们求s[i][j]时，s[i-2]行的元素我们就不再需要，我们只需要s[i-1]行中的元素，我们把s[i-1]行中的元素保存在up数组中，数组的大小为m。我们把s[i]保存在now数组中，当s[i]行的元素计算完毕以后，我们交换up和now数组。因为需要up数组和now数组，且数组的大小都为m，所以我们需要2*m大小的额外空间。 def minPathSum(self, grid): if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) up = [grid[0][0]]*m now = [0] *m for j in range(1,m): up[j] = grid[0][j] + up[j-1] for i in range(1,n): now[0] = grid[i][0] + up[0] for j in range(1,m): # pre[j]:上元素 tmp:左元素，求和后，tmp也为左元素 now[j] = min(up[j],now[j-1]) + grid[i][j] up = now.copy() return up[-1] (动态规划3)：时间复杂度为o(nm)，空间复杂度为o(m)，需要m大小的额外空间，注意此方法和方法三的区别，方法三需要2m大小的额外空间，此方法只需要m大小的额外空间，在方法三中我们保存当前行s[i]中的元素，假设我们当前计算s[i][j]，我们只需要知道s[i][j-1]的值即可，不需要保存s[i]行中的元素。每次计算s[i][j]时，我们需要更新up[j]的值。 def minPathSum(self, grid): if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) up = [grid[0][0]]*m for j in range(1,m): up[j] = grid[0][j] + up[j-1] for i in range(1,n): tmp = grid[i][0] + up[0] up[0] = tmp for j in range(1,m): # pre[j]:上元素 tmp:左元素，求和后，tmp也为左元素 tmp = min(up[j],tmp) + grid[i][j] up[j] = tmp return up[-1] 非原地修改，动态规划 def minPathSum(self, grid): if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) mat = [[grid[0][0]]*m]*n for i in range(1,n): mat[i][0] = mat[i-1][0] + grid[i][0] for j in range(1,m): mat[0][j] = mat[0][j-1] + grid[0][j] for i in range(1,n): for j in range(1,m): mat[i][j] = min(mat[i][j-1], mat[i-1][j]) + grid[i][j] return mat[-1][-1] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:39:21 "},"矩阵/长度最小的子数组.html":{"url":"矩阵/长度最小的子数组.html","title":"长度最小的子数组","keywords":"","body":"长度最小的子数组 1.题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例: 输入: s = 7, nums = [2,3,1,2,4,3] 输出: 2 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 2.分析 滑动窗口法 3.代码 class Solution: def minSubArrayLen(self, s, nums): sum_all = 0 left, right = 0, 0 nums_len = len(nums) min_len = nums_len+1 while left = s: min_len = min(min_len, right-left) if min_len == nums_len+1: return 0 else: return min_len Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:40:10 "},"矩阵/两数之和 II - 输入有序数组.html":{"url":"矩阵/两数之和 II - 输入有序数组.html","title":"两数之和 II - 输入有序数组","keywords":"","body":"两数之和 II - 输入有序数组 1.题目 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 2.分析 暴力法， 二分法， 指针对撞法 3.代码 暴力法 暴力解决 def twoSum(self, numbers: List[int], target: int) -> List[int]: for i in range(len(numbers)-1): for j in range(i+1,len(numbers)): if i!=j and numbers[i]+numbers[j] == target: return [i+1,j+1] return [] 二分法 def binary_search(self, li, left, right, val): while left li[mid][0]: left = mid + 1 else: right = mid - 1 else: return None def twoSum(self, nums, target): for i in range(len(nums)): a = nums[i] b = target - a if b > a: j = self.binary_search(nums, i + 1, len(nums) - 1, b) else: j = self.binary_search(nums, 0, i - 1, b) if j and j!=i: break return [i+1, j+1] 指针对撞法 def twoSum(self, numbers, target): left, right = 0, len(numbers)-1 sum_all = 0 while left target: right -= 1 elif sum_all Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:38:51 "},"矩阵/两数之和 II - 输入无须数组.html":{"url":"矩阵/两数之和 II - 输入无须数组.html","title":"两数之和 II - 输入无须数组","keywords":"","body":"两数之和 II - 输入无须数组 1.题目 2.分析 3.代码 3.1二分法 class Solution: def binary_search(self, li, left, right, val): while left li[mid][0]: left = mid + 1 else: right = mid - 1 else: return None def twoSum(self, nums, target): new_list = [[num,i] for i,num in enumerate(nums)] new_list.sort() for i in range(len(new_list)): a = new_list[i][0] b = target - a if b > a: j = self.binary_search(new_list, i + 1, len(new_list) - 1, b) else: j = self.binary_search(new_list, 0, i - 1, b) if j: break return [new_list[i][1], new_list[j][1]] ret = Solution() print(ret.twoSum([-1,-3,-2],-5)) 3.2字典法 class Solution: def twoSum(self, nums, target): nums_len = len(nums) for i in range(nums_len): dif = target - nums[i] if dif in nums[:i]: return [nums.index(dif), i] return [] 3.3字典法 class Solution: def twoSum(self, nums, target): bag = {} for index, value in enumerate(nums): dif = target - value if dif in bag: return [index, bag[dif]] return [] 3.4切片法 class Solution: def twoSum(self, nums, target): nums_len = len(nums) for i in range(nums_len): dif = target - nums[i] if dif in nums[:i]: return [nums.index(dif), i] return [] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:38:38 "},"矩阵/螺旋矩阵.html":{"url":"矩阵/螺旋矩阵.html","title":"螺旋矩阵","keywords":"","body":"螺旋矩阵 1.题目 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 2.分析 ​ 对于这种螺旋遍历的方法，重要的是要确定上下左右四条边的位置，那么初始化的时候，上边up就是0，下边down就是m-1，左边left是0，右边right是n-1。然后我们进行while循环，先遍历上边，将所有元素加入结果res，然后上边下移一位，如果此时上边大于下边，说明此时已经遍历完成了，直接break。同理对于下边，左边，右边，依次进行相对应的操作，这样就会使得坐标很有规律，并且不易出错，参见代码如下： 3.代码 def spiralOrder(self, matrix: List[List[int]]) -> List[int]: if not matrix: return [] u, d, l, r = 0, len(matrix)-1, 0, len(matrix[0])-1 res = [] while True: for i in range(l,r+1):res.append(matrix[u][i]) u += 1 if u > d:break for i in range(u,d+1):res.append(matrix[i][r]) r -= 1 if r r:break # print(res) return res class Solution { public List spiralOrder(int[][] matrix) { // 对于这种螺旋遍历的方法，重要的是要确定上下左右四条边的位置，那么初始化的时候，上边up就是0，下边down就是m-1， // 左边left是0，右边right是n-1。然后我们进行while循环，先遍历上边，将所有元素加入结果res，然后上边下移一位， // 如果此时上边大于下边，说明此时已经遍历完成了，直接break List res = new ArrayList<>(); if (matrix == null || matrix.length == 0) return res; int n = matrix.length; int m = matrix[0].length; int u=0, d=n-1, l=0, r=m-1; while (true) { for (int i = l; i d) break; for (int i = u; i = l; i--) res.add(matrix[d][i]); if (--d = u; i --) res.add(matrix[i][l]); if (++l > r) break; } return res; } } Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-06 13:01:19 "},"矩阵/螺旋矩阵 II LeetCode 53.html":{"url":"矩阵/螺旋矩阵 II LeetCode 53.html","title":"螺旋矩阵 II_LeetCode 53","keywords":"","body":"螺旋矩阵 II(LeetCode 53) 1.题目 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 2.分析 实现思路：给定四个边界，left = 0,right = n-1, top = 0,bottom = n-1, 然后每次进行四遍循环， (top)left->right 循环结束后top+1 (right)top->bottom 循环结束后right-1 (bottom)right->left 循环结束后bottom-1 (left)bottom->top 循环结束后left+1 循环结束条件为index = n*n 3.代码 def generateMatrix(self, n): u, d, l, r = 0, n-1, 0, n-1 matrix = [[0]*n for _ in range(n)] index = 0 while index java class Solution { public int[][] generateMatrix(int n) { int[][] res = new int[n][n]; int u=0, d=n-1, l=0, r=n-1; int num = 1; while (true) { for (int i = l; i d) break; for (int i = u; i = l; i--) res[d][i] = num++; if (--d = u; i--) res[i][l] = num++; if(++l > r) break; } return res; } } java public int[][] generateMatrix(int n) { int l = 0, r = n - 1, t = 0, b = n - 1; int[][] mat = new int[n][n]; int num = 1, tar = n * n; while(num = l; i--) mat[b][i] = num++; // right to left. b--; for(int i = b; i >= t; i--) mat[i][l] = num++; // bottom to top. l++; } return mat; } Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-06 13:03:16 "},"矩阵/有序矩阵中第K小的元素.html":{"url":"矩阵/有序矩阵中第K小的元素.html","title":"有序矩阵中第K小的元素","keywords":"","body":"有序矩阵中第K小的元素 1.题目 给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。 请注意，它是排序后的第k小元素，而不是第k个元素。 示例: matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, 返回 13。 说明: 你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。 2.分析 我们使用一个最大堆，然后遍历数组每一个元素，将其加入堆，根据最大堆的性质，大的元素会排到最前面，然后我们看当前堆中的元素个数 是否大于k，大于的话就将首元素去掉，循环结束后我们返回堆中的首元素即为所求: 3.代码 class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -> int: # 我们使用一个最大堆，然后遍历数组每一个元素，将其加入堆，根据最大堆的性质，大的元素会排到最前面，然后我们看当前堆中的元素个数 # 是否大于k，大于的话就将首元素去掉，循环结束后我们返回堆中的首元素即为所求: import heapq tmp = [] edge = len(matrix) for i in range(edge): for j in range(edge): heapq.heappush(tmp,-matrix[i][j]) if len(tmp) > k: heapq.heappop(tmp) print(-tmp[0]) return -tmp[0] ​ Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:01 "},"链表/":{"url":"链表/","title":"链表","keywords":"","body":"链表 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-08 00:43:19 "},"链表/链表归并排序.html":{"url":"链表/链表归并排序.html","title":"链表归并排序","keywords":"","body":"链表归并排序 1.题目 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4->2->1->3 输出: 1->2->3->4 示例 2: 输入: -1->5->3->4->0 输出: -1->0->3->4->5 2.分析 归并排序采用分治思想，首先使其子序列成为有序序列，然后再对子序列进行归并。 递归实现： 首先把链表分割为两个子链表（采用快慢指针找到链表中间节点），递归该分割过程，直至子链表只包含一个节点为止； 创建一个新的链表节点，指向排序好的链表；对分割得到的两个子链表逐一遍历对比，值小的节点插入到新链表后面； 两个子链表归并完成，且已完成对其排序，返回链表头指针给上层递归。 3.代码 链表归并 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: # 归并排序 def sortList(self, head: ListNode) -> ListNode: def split_List(head): if head == None or head.next == None: return head fast = slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next tmp = slow slow = slow.next # print(slow.val) tmp.next = None return slow , head def merger_sort(head): if head == None or head.next ==None: return head head1, head2 = split_List(head) head1 = merger_sort(head1) head2 = merger_sort(head2) return merger(head1, head2) def merger(head1, head2): if head1 == None:return head2 if head2 == None:return head1 new_head = tail = ListNode(-1) while head1 and head2: if head1.val [!NOTE] split_List函数 slow = slow.next tmp.next = None 不要写反了 写成这样就错了 tmp.next = None slow = slow.next 列表归并，作为参考 # 归并，现在左右两个列表已经是有序的了 # 这儿用low、mid、high，是因为后续还会调用这个函数，会写成递归 def merge(li, low, mid, high): i = low # 第二个有序列表的第一个元素 j = mid+1 ltmp = [] # 左右两边都有数 while i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 23:28:39 "},"链表/合并两个有序链表 LeetCode 21.html":{"url":"链表/合并两个有序链表 LeetCode 21.html","title":"合并两个有序链表__LeetCode 21","keywords":"","body":"合并两个有序链表(LeetCode 21) 1.题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 2.分析 ​ 新建立一个新的链表。建立两个指针cur1和cur2，分别指向两个链表。然后只需要通过比较两个链表每个元素的大小，小的元素添加到新的链表中即可。最后，我们要分别判断cur1和cur2是否是各自链表的末尾，如果不是，将剩余元素添加到新的链表末尾即可。 3.代码 非递归 # 对于链表的问题，根据以往的经验一般都是要建一个dummy node，连上原链表的头结点，这样的话就算头结点变动了，我们还可以通过dummy->next来获得新链表的头结点。 def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode: tail = head = ListNode(0) while l1 and l2: if l1.val [!NOTE] if l1: tail.next = l1 if l2: tail.next = l2 改为：tail.next = l1 or l2 代码2非递归 def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode: if not l1: return l2 if not l2: return l1 tail = head = ListNode(0) while l1 and l2: if l1.val 递归版 def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode: if not l1:return l2 if not l2:return l1 if l1.val java class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) return l2; if (l2 == null) return l1; ListNode dummy, head; dummy = new ListNode(-1); head = dummy; while (l1 != null && l2 != null) { if (l1.val Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-06 00:43:01 "},"链表/合并K个排序链表.html":{"url":"链表/合并K个排序链表.html","title":"合并K个排序链表","keywords":"","body":"合并K个排序链表 1.题目 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入: [ 1->4->5, 1->3->4, 2->6 ] 输出: 1->1->2->3->4->4->5->6 2.分析 ​ 首先将list中的每个 链表 比较首元素，然后依次加入优先队列（或者一个堆，我这里使用堆） 然后判断这个 优先队列 是否为空，不为空，我们弹出队首元素（1），接着判断这个弹出的元素作为一个链表节点，其后是否还有元素，如果有元素，将元素加入队列。同时将结果加入到result中 3.代码 优先队列（每次只加入各队列最小值比较） def mergeKLists(self, lists: List[ListNode]) -> ListNode: import heapq gw = [] new_head = cur = ListNode(0) x = 0 for i in lists: if i: heapq.heappush(gw, (i.val, x, i)) x += 1 while len(gw) > 0: tmp = heapq.heappop(gw)[2] cur.next = tmp cur = cur.next if tmp.next: heapq.heappush(gw, (tmp.next.val, x, tmp.next)) x += 1 return new_head.next 优先队列（一次性加入所有元素） def mergeKLists(self, lists): import heapq result = ListNode(-1) cur = result p = list() x = 0 for i in lists: while i: heapq.heappush(p, (i.val, x, i)) i = i.next x += 1 while p: cur.next = heapq.heappop(p)[2] cur = cur.next return result.next 分治法（未完成） def mergeKLists(self, lists: List[ListNode]) -> ListNode: def merge(a, b): head = ListNode(0) cur = head while a and b: if a.val > b.val: cur.next = b b = b.next else: cur.next = a a = a.next cur = cur.next if a: cur.next = a if b: cur.next = b return head.next # 采用分治法 n = len(lists) if n == 0: return None def deal(l, r): if l > r: return None if l == r: return lists[0] middle = (l+r) // 2 a = deal(l, middle) b = deal(middle, r) return merge(a, b) return deal(0, n-1) [!NOTE] ​ 当对一个 tuple 排序时， python 会从 0 开始对两个 tuple 的成员依次比较，如果两个成员相同就再比较下一个成员。问题中的 tuple 很有趣，前两个链表的第一项比较结果都相同（ 1 ），于是 python 开始比较第二个成员，第二个成员是一个ListNode，没有比较方法，在处理这个问题上 py2 和 py3 有了差异， py2 随机瞎排， py3 则是抛出异常。 一种解决办法是我们重写一个ListNode，给他添加val元素方法。我这里使用了另外的一种解决思路，就是在tuple中再添加一个元素。 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:41 "},"链表/旋转链表 LeetCode 61.html":{"url":"链表/旋转链表 LeetCode 61.html","title":"旋转链表__LeetCode 61","keywords":"","body":"旋转链表(LeetCode 61) 1.题目 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: 1->2->3->4->5->NULL, k = 2 输出: 4->5->1->2->3->NULL 解释: 向右旋转 1 步: 5->1->2->3->4->NULL 向右旋转 2 步: 4->5->1->2->3->NULL 示例 2: 输入: 0->1->2->NULL, k = 4 输出: 2->0->1->NULL 解释: 向右旋转 1 步: 2->0->1->NULL 向右旋转 2 步: 1->2->0->NULL 向右旋转 3 步: 0->1->2->NULL 向右旋转 4 步: 2->0->1->NULL 2.分析 这个问题其实和 Leetcode 19: 删除链表的倒数第 N 个节点（最详细解决方案！！！）是一样的。其实就是一个循环链表首先，如果head == None or head.next == None我们直接返回head就可以了。 因为q = q.next，所以是左旋 3.代码 def rotateRight(self, head: ListNode, k: int) -> ListNode: if head == None or head.next == None: return head # 初始有一个点 count = 1 cur = head while cur.next: count += 1 # 前指针，这儿没有用，但是可以看看怎么写 # pre = cur cur = cur.next # 首尾连接 cur.next = head # 从尾巴开始左旋 tmp = cur # print(cur.val) k = count - k%count for _ in range(k): # 这句话阐述了是左旋，我们可以这么理解，左边的等于右边的就是左旋；右边的等于左边的，就是右旋 tmp = tmp.next # 旋转完毕，断开换 new_head = tmp.next tmp.next = None return new_head Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:59 "},"链表/环形链表 LeetCode 141.html":{"url":"链表/环形链表 LeetCode 141.html","title":"环形链表_LeetCode 141.md","keywords":"","body":"环形链表(LeetCode 141) 1.题目 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 2.分析 快慢指针 解法3：不使用额外空间，设置两个指针p1,p2，开始均指向头结点，然后每次p1向后移动一个节点，p2向后移动两个节点。然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。有“环”自会“重逢”。 此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。 3.代码 if not head or not head.next:return False fast = slow = head while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: return True return False 置空法 def hasCycle(self, head): if not head: return False while head.next and head.val != None: head.val = None # 遍历的过程中将值置空 head = head.next if not head.next: # 如果碰到空发现已经结束，则无环 return False return True # 否则有环 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 16:41:04 "},"链表/链表逆序输出 不带头结点.html":{"url":"链表/链表逆序输出 不带头结点.html","title":"链表逆序输出（不带头结点）","keywords":"","body":"链表逆序输出（不带头结点） 1.题目 2.分析 递归 3.代码 def reversePrint(head): if not head: return reversePrint(head.next) print(head.val) 还可以先逆序，后输出，逆序有多种方法，就低逆序，递归逆序 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 00:54:33 "},"链表/环形链表 II LeetCode 142.html":{"url":"链表/环形链表 II LeetCode 142.html","title":"环形链表 II_LeetCode 142","keywords":"","body":"环形链表 II(LeetCode 142) 1.题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：tail connects to node index 0 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：no cycle 解释：链表中没有环。 进阶： 你是否可以不用额外空间解决此题？ 2.分析 使用快慢指针先确定是否有环，有的话，将fast指向head，和slow指针以相同的速度移动，当fast==slow时则找到了环的入口。 第一次相遇，肯定是在环内，因为快指针比慢指针快一倍，所以，快指针比慢指针多走一倍路程，其中满指针走过的路程就是这一倍路程，快指针走的两倍路程是这样来的，慢指针的一倍路程，加上圆圈的长度（从相遇点出发，沿着环走，再次回到相遇点）。现在两个指针都剪掉，入环点到相遇点的路程，两边剩下的路程长度相同（慢指针到入环点，和快指针从入环点逆时针回到相遇点），所以，一个从head出发，一个从相遇点出发，走到入环点的路程长度相同。 3.代码 字典法 def detectCycle(self, head): if head == None: return None bag = {} index = 0 while head.next: if head not in bag: bag[head] = index index += 1 head = head.next else: # 输出环形链表是第几个节点，但是有错，深拷贝也不行 # return bag[cur] return head return None 快慢指针，写成两个函数 class Solution(object): def detectCycle(self, head): count = self.func(head) if count ==0:return None t1,t2 = head,head for i in range(count): t2 = t2.next while t1!=t2: t1 = t1.next t2 = t2.next return t1 # 先判断有没有环 def func(self,head): if head == None or head.next == None: return 0 fast = slow = head count = 0 while fast.next and fast.next.next: count+=1 fast = fast.next.next slow = slow.next if fast == slow: return count return 0 快慢指针，写成一个函数 class Solution(object): def detectCycle(self, head): if not head or not head.next: return None fast = slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next if fast == slow: slow = head while fast != slow: fast = fast.next slow = slow.next return fast return None Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:24 "},"链表/相交链表 LeetCode 160.html":{"url":"链表/相交链表 LeetCode 160.html","title":"相交链表 LeetCode 160","keywords":"","body":"相交链表(LeetCode 160) 1.题目 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 2.分析 判断地址，而不是val，因为那两个1实际上不是同一个节点，地址不同，直接判断地址就行了 首尾相连法: 同时对A和B进行遍历, 并且让到达末尾的指针指向另一个链表的头结点. 例如A: 6->7->4->5; B: 1->2->3->4->5 遍历时会相交于4 (67451234, 12345674). 备用法（未实现）: 求出两个链表A和B的长度, 长链表先走|len(A)-len(B)|步, 然后同时遍历返回第一个公共节点. 3.代码 首尾相连法 def getIntersectionNode(self, headA, headB): # 首尾相连法 if headA is None or headB is None: return None # 因为过一会还要用headB，headA，所以这儿先用其他变量保存 p = headA q = headB while p != q: p = p.next if p else headB q = q.next if q else headA return p 字典法 def getIntersectionNode(self, headA, headB): d = {} while headA: d[headA] = 1 headA = headA.next while headB: if headB in d: return headB headB = headB.next return None 集合法 def getIntersectionNode(self, headA, headB): d = set() while headA: d.add(headA) headA = headA.next while headB: if headB in d: return headB headB = headB.next return None Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 19:00:46 "},"链表/删除链表中的节点 LeetCode 237.html":{"url":"链表/删除链表中的节点 LeetCode 237.html","title":"删除链表中的节点 LeetCode 237","keywords":"","body":"删除链表中的节点 LeetCode 237 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 -- head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9. 示例 2： 输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" node.val = node.next.val node.next = node.next.next Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-19 10:07:11 "},"链表/反转链表.html":{"url":"链表/反转链表.html","title":"反转链表","keywords":"","body":"反转链表 1.题目 反转一个单链表。 示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 2.分析 头插法 迭代法 假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。 在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！ 递归法 递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？ 假设列表为：$n1→...→nk−1→nk→nk+1→...→nm→∅$ 若从节点 $n{k+1}nk+1 $到 $n{m}nm $已经被反转，而我们正处于 $n_{k}nk$。 $n1→...→nk−1→nk→nk+1←...←nm$ 我们希望 $n{k+1}n k+1$ 的下一个节点指向$n{k}nk$。 所以，$n{k}nk.next.next = n{k}nk。$ 要小心的是$n1$ 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。 ​ 3.代码 头插法 # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head: ListNode) -> ListNode: # 有毛病吧，不带头结点的链表 # 插入法 if head is None: return cur = None # 当前节点 next = None# 后继节点 cur = head.next head.next = None # 设置链表的第一个节点为尾节点 # 把遍历到的节点插入到头结点后面去 while cur: next = cur.next cur.next = head head = cur cur = next return head 就地反转 class Solution: def reverseList(self, head: ListNode) -> ListNode: if head is None or head.next is None: return head pre = None cur = head while cur is not None: next = cur.next cur.next = pre pre = cur cur = next return pre 递归法(没有头结点) 我们知道reverseList(head)返回输入的链表反转后的head，那么如果reverseList(head.next)的话 head 1->2我们此时只需要head.next.next=head，也就是先建立一个双向连接 head 1->2然后再head.next=None，返回node即可 head null def reverseList(self, head: ListNode) -> ListNode: if not head or not head.next: return head new_head = self.reverseList(head.next) head.next.next = head head.next = None return new_head 递归法（有头结点） def reverseList(self, head: ListNode) -> ListNode: if not head: return head first_node = head.next new_head = self.reverseList(first_node) head.next.next = None return new_head 古老办法 def reverseList(self, head: ListNode) -> ListNode: 输出节点值到列表，重建链表 move = head tail = head head = None res = [] while move: res.append(move.val) move = move.next for element in res: node = ListNode(element) node.next = head head = node return head Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 00:53:08 "},"链表/反转链表2.html":{"url":"链表/反转链表2.html","title":"反转链表2","keywords":"","body":"反转链表 II(LeetCode_92) 1.题目 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1->2->3->4->5->NULL, m = 2, n = 4 输出: 1->4->3->2->5->NULL 2.分析 3.代码 # 对于链表的问题，根据以往的经验一般都是要建一个dummy node，连上原链表的头结点，这样的话就算头结点变动了，我们还可以通过dummy->next来获得新链表的头结点。 def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode: dummy = ListNode(-1) dummy.next = head fpre = dummy for _ in range(m-1): fpre = fpre.next pre = None # fpre 指向 1 # cur 指向 4 cur = fpre.next for _ in range(n-m+1): next = cur.next cur.next = pre pre = cur cur = next # 将翻转部分 和 原链表拼接 # 不能交换位置 fpre.next.next = cur # 1.2(next).next = 5,同时没有破坏1.next = 4 . 如果先执行fpre.next = pre 则fpre.next.next找不到了 fpre.next = pre # 1.next = 4 return dummy.next Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 09:04:55 "},"链表/对链表进行插入排序_LeetCode_147.html":{"url":"链表/对链表进行插入排序_LeetCode_147.html","title":"对链表进行插入排序_LeetCode_147","keywords":"","body":"对链表进行插入排序 1.题目 对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。 每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1： 输入: 4->2->1->3 输出: 1->2->3->4 示例 2： 输入: -1->5->3->4->0 输出: -1->0->3->4->5 2.分析 注意：我们必须先定义一个头结点 3.代码 # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def insertionSortList(self, head: ListNode) -> ListNode: if head == None or head.next == None: return head dummyHead = ListNode(-1) while head: # pre.next的先序节点 pre = dummyHead # 存储下一个无序区节点 while pre.next and head.val > pre.next.val: pre = pre.next head.next = pre.next pre.next = head head = next return dummyHead.next Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 23:27:21 "},"链表/两数相加-链表 LeetCode 2.html":{"url":"链表/两数相加-链表 LeetCode 2.html","title":"两数相加-链表__LeetCode 2","keywords":"","body":"两数相加-链表（LeetCode 2） 1.题目 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 2.分析 3.代码 def addTwoNumbers(self, l1, l2): cur = ret = ListNode(0) add = 0 while l1 or l2 or add: val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + add add = val // 10 cur.next = ListNode(val % 10) cur = cur.next l1 = l1.next if l1 else None l2 = l2.next if l2 else None return ret.next Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:29 "},"链表/删除链表的倒数第K个节点.html":{"url":"链表/删除链表的倒数第K个节点.html","title":"删除链表的倒数第K个节点","keywords":"","body":"删除链表的倒数第N个节点(LeetCode_19) 1.题目 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3->5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 2.分析 ​ 第一个指针从列表的开头向前移动 n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。 3.代码 class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode: if head is None or n 0: pass elif n # 首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。 def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode: dummy = ListNode(0) dummy.next = head fast = slow = dummy # 这个比查找倒数第N个节点多走一步,因为我们需要找到倒数第N+1个节点,我们才能删除倒数第N个节点 # 大于0，就是走n步 while n>0: n -= 1 fast = fast.next # 退出循环的条件为fast指向最后个节点 while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return dummy.next def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode: # 为了更好的处理删除头结点情况,我们一般都会设置虚拟节点 dummy = ListNode(0) dummy.next = head fast = slow = dummy count = 0 # 退出循环的条件是fast刚好指向最后个节点。此时,slow指向倒数第n+1个节点,这样就能删除倒数第n个节点 while fast.next: count += 1 # 先让fast走n步,第n+1步时候,slow也开始走 if count > n: slow = slow.next fast = fast.next # 如果题目增加难度,说如果n不满足条件,就返回None,就可以用下面两句 # if count def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" # 思路：双指针法。 slow = fast = head for i in range(n): # 先让fast走n步 fast = fast.next if fast == None: # 若走了n步后为None，则表明删除的为head节点 return head.next while fast.next != None: # slow和fast同时往前走 slow = slow.next # 当fast走到头时，second即是要删除节点的前一个节点位置 fast = fast.next slow.next = slow.next.next # 删除该节点 return head Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 00:14:08 "},"链表/环形单链表约瑟夫问题.html":{"url":"链表/环形单链表约瑟夫问题.html","title":"环形单链表约瑟夫问题","keywords":"","body":"环形单链表约瑟夫问题 1.题目 输入 一个环形单向链表的头结点head和报数的值m 返回 最后生存下来的节点 2.分析 3.代码 def func(self, head, m): if head is None or head.next == head or m Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-19 13:05:53 "},"链表/回文链表.html":{"url":"链表/回文链表.html","title":"回文链表","keywords":"","body":"回文链表(LeetCode_234) 1.题目 请判断一个链表是否为回文链表。 示例 1: 输入: 1->2 输出: false 示例 2: 输入: 1->2->2->1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 2.分析 判断一个链表是否是回文的，很自然的想法就是两个指针，一个指针从前往后走，一个指针从后往前走，判断元素值是否相同， 这里要分几个步骤来进行求解： 1、找到链表长度的一半，用追赶法，一个指针一次走两步，一个指针一次走一步 2、将后一半数组转置 3、判断链表是否是回文链 3.代码 class Solution: def isPalindrome(self, head: ListNode) -> bool: # 判断一个链表是否是回文的，很自然的想法就是两个指针，一个指针从前往后走，一个指针从后往前走，判断元素值是否相同， # 这里要分几个步骤来进行求解： # 1、找到链表长度的一半，用追赶法，一个指针一次走两步，一个指针一次走一步 # 2、将后一半数组转置 # 3、判断链表是否是回文链 if head == None or head.next == None: return True slow= fast = head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next pre = None while slow: nxt = slow.next slow.next = pre pre = slow slow = nxt while pre and head: if pre.val != head.val: return False pre = pre.next head = head.next return True Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-19 13:23:45 "},"链表/删除排序链表中的重复元素 LeetCode 83.html":{"url":"链表/删除排序链表中的重复元素 LeetCode 83.html","title":"删除排序链表中的重复元素 LeetCode 83","keywords":"","body":"删除排序链表中的重复元素(LeetCode 83) 1.题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1->1->2 输出: 1->2 示例 2: 输入: 1->1->2->3->3 输出: 1->2->3 2.分析 3.代码 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:38 "},"链表/删除排序链表中的重复元素 II LeetCode 82.html":{"url":"链表/删除排序链表中的重复元素 II LeetCode 82.html","title":"删除排序链表中的重复元素 II LeetCode 82","keywords":"","body":"删除排序链表中的重复元素 II(LeetCode 82) 1.题目 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1->2->3->3->4->4->5 输出: 1->2->5 示例 2: 输入: 1->1->1->2->3 输出: 2->3 2.分析 3.代码 def deleteDuplicates(self, head: ListNode) -> ListNode: # 设置虚拟头结点 if head is None: return newHead = ListNode(None) newHead.next = head pre = newHead cur = head while cur: if cur.next and cur.val == cur.next.val: # 如果重复元素有很多个连着的，需要走到重复元素的最后一个 while cur.next and cur.val == cur.next.val: cur = cur.next pre.next = cur.next cur = cur.next else: pre = pre.next cur = cur.next # 最后不能返回head,因为【1，1，2，3】->【2，3】,head一直都指着链表的第一个元素 return newHead.next 延伸一 不设置虚拟头结点，删除有序列表，但是最后要保留一个，而不是全部删 #除 【1，2，3，3】->【1,2,3】 if head is None: return pre = head cur = head.next while cur: if pre.val == cur.val: pre.next = cur.next cur = cur.next else: pre = cur cur = cur.next return head 延伸二 设置虚拟头结点，删除有序列表，但是最后要保留一个，而不是全部删 #除 【1，2，3，3】->【1,2,3】 if head is None: return newHead = ListNode(None) newHead.next = head pre = newHead cur = head while cur: if cur.next and cur.val == cur.next.val: pre.next = cur.next cur = cur.next else: pre = cur cur = cur.next return newHead.next Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:38 "},"链表/链表的中间结点 LeetCode 876.html":{"url":"链表/链表的中间结点 LeetCode 876.html","title":"链表的中间结点 LeetCode 876","keywords":"","body":"链表的中间结点(LeetCode 876) 1.题目 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 2.分析 快慢指针，不过最后要分奇数、偶数讨论 当链表长度为奇数时，快指针走到链表尾部时，慢指针恰好指向链表的中间 当链表长度为偶数时，慢指针所指节点和所指节点的下一节点都是链表的中间节点 计算链表节点个数，然后扫描 3.代码 快慢指针 class Solution(object): def middleNode(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head or not head.next:return False fast = slow = head while fast and fast.next: fast = fast.next.next slow = slow.next # [1,2,3,4,5] 奇数个,又因为fast一次跳两个,所以第一次跳到3,第二次跳到5,所以当元素个数为奇数时候,fast.next为空,返回slow.next # [1,2,3,4,5,6] 偶数个, fast第一次跳到3,第二次跳到5,由于fast.next.next为None,所以退出循环,所以fast.next.val == 6, fast.next不为空 if fast.next: return slow.next else: return slow 遍历法 def middleNode(self, head: ListNode) -> ListNode: if head == None or head.next == None: return head k = 1 cur = head while cur.next: k += 1 cur = cur.next k //=2 while k>0: head = head.next k -= 1 return head Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 16:37:38 "},"链表/K 个一组翻转链表_LeetCode_25.html":{"url":"链表/K 个一组翻转链表_LeetCode_25.html","title":"K 个一组翻转链表_LeetCode_25","keywords":"","body":"K 个一组翻转链表(LeetCode_25) 1.题目 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 : 给定这个链表：1->2->3->4->5 当 k = 2 时，应当返回: 2->1->4->3->5 当 k = 3 时，应当返回: 3->2->1->4->5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 2.分析 递归 3.代码 class Solution(object): def reverseKGroup(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" count = 0 cur = head while cur and count Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 09:07:54 "},"链表/查找链表倒数第N个节点.html":{"url":"链表/查找链表倒数第N个节点.html","title":"查找链表倒数第N个节点","keywords":"","body":"class Solution: def FindKthToTail(self, head, k): # write code here if head==None or k k-1: slow = slow.next if count class Solution: def FindKthToTail(self, head, k): # write code here if head==None or k1: if fast.next: fast = fast.next k -= 1 else: return None while fast.next is not None: fast = fast.next slow = slow.next return slow Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 00:11:08 "},"二叉树/":{"url":"二叉树/","title":"二叉树","keywords":"","body":"二叉树 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 22:00:38 "},"二叉树/二叉树的最大深度.html":{"url":"二叉树/二叉树的最大深度.html","title":"二叉树的最大深度","keywords":"","body":"二叉树的最大深度 1.题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 2.分析 3.代码 递归 def maxDepth(self, root: TreeNode) -> int: 如果二叉树为空，则深度为0 如果不为空，分别求左子树的深度和右子树的深度，取最大的再加1。 if root == None: return 0 left = self.maxDepth(root.left) right = self.maxDepth(root.right) return left+1 if left>right else right+1 递归简单修改 def maxDepth(self, root: TreeNode) -> int: 法一简单修改 if not root: return 0 return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1 递归简单修改2 def maxDepth(self, root: TreeNode) -> int: 第二种就是判断左子树或右子树是否为空，若左子树为空，则返回右子树的深度，反之返回左子树的深度， 如果都不为空，则返回左子树和右子树深度的最小值。 def minDepth(self,root): if root == None: return 0 if root.left == None: return self.minDepth(root.right) if root.right == None: return self.minDepth(root.left) return min(self.minDepth(root.left),self.minDepth(root.right)) + 1 def TreeDepth(self, pRoot): # write code here if not pRoot: return 0 queue = [pRoot] depth = 0 while queue: tmp = [] depth += 1 for node in queue: if node.left: tmp.append(node.left) if node.right: tmp.append(node.right) queue = tmp return depth Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 12:30:39 "},"二叉树/二叉树的层次遍历.html":{"url":"二叉树/二叉树的层次遍历.html","title":"二叉树的层次遍历","keywords":"","body":"二叉树的层次遍历 1. 二叉树的深度（通过层次遍历实现）(每层节点单独输出) def maxDepth(self, root: TreeNode) -> int: if not root: return 0 res = [] # 层次遍历 depth, queue = 0, [root] while queue: res_temp = [] # 每层节点 depth += 1 tmp = [] for node in queue: print(node.val) res_temp.append(node.val) if node.left: tmp.append(node.left) if node.right: tmp.append(node.right) res.append(res_temp) queue = tmp print(res) return depth 2. 层次遍历简写 def levelOrder(self, root): from collections import deque if root == None: return [] queue = deque() queue.append(root) res = [] while queue: p = queue.popleft() # p = queue.pop(0) res.append(p.val) if p.left: queue.append(p.left) if p.right: queue.append(p.right) print(res) 3. 层次遍历（每层单独输出） def levelOrder(self, root): from collections import deque if root == None: return [] queue = deque() queue.append(root) res = [] while queue: res_tmp = [] queue_tmp = [] for node in queue: res_tmp.append(node.val) if node.left: queue_tmp.append(p.left) if node.right: queue_tmp.append(p.right) queue = queue_tmp res.append(res_tmp) print(res) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-11 23:41:03 "},"二叉树/二叉树的层次遍历 II.html":{"url":"二叉树/二叉树的层次遍历 II.html","title":"二叉树的层次遍历 II","keywords":"","body":"二叉树的层次遍历 II 1.题目 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其自底向上的层次遍历为： [ [15,7], [9,20], [3] ] 2.分析 3.代码 class Solution: def levelOrderBottom(self, root: TreeNode) -> List[List[int]]: res = [] if root == None: return res queue = [root] while queue: queue_tmp = [] res_tmp = [] for node in queue: res_tmp.append(node.val) if node.left: queue_tmp.append(node.left) if node.right: queue_tmp.append(node.right) queue = queue_tmp res.insert(0, res_tmp) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:34 "},"二叉树/二叉树的锯齿形层次遍历 LeetCode 103.html":{"url":"二叉树/二叉树的锯齿形层次遍历 LeetCode 103.html","title":"二叉树的锯齿形层次遍历 LeetCode 103","keywords":"","body":"二叉树的锯齿形层次遍历(LeetCode 103) 1.题目 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树 [3,9,20,null,null,15,7], ```sql lite 3 / \\ 9 20 / \\ 15 7 返回锯齿形层次遍历如下： [ [3], [20,9], [15,7] ] #### 2.分析 和层次遍历一样，只不过加一个，判断语句 #### 3.代码 ```python def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]: if root == None: return [] res = [] queue = [root] deepth = 0 while queue: deepth += 1 res_tmp = [] queue_tmp = [] for node in queue: if deepth%2==0: res_tmp.append(node.val) else: res_tmp.insert(0,node.val) if node.right: queue_tmp.append(node.right) if node.left: queue_tmp.append(node.left) queue = queue_tmp res.append(res_tmp) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-11 20:25:06 "},"二叉树/路径总和 LeetCode 112.html":{"url":"二叉树/路径总和 LeetCode 112.html","title":"路径总和 LeetCode 112","keywords":"","body":"路径总和(LeetCode 112) 1.题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。 2.分析 3.代码 def hasPathSum(self, root: TreeNode, sum: int) -> bool: if not root: return False # 如果当前节点是叶子节点,且路径之和等于sum if not root.left and not root.right and root.val == sum: return True else: return self.hasPathSum(root.left,sum-root.val) or self.hasPathSum(root.right,sum-root.val) return False 还有个办法就是回溯，然后统计结果集是否为空 def hasPathSum(self, root: TreeNode, sum: int) -> bool: if not root: return False # 如果当前节点是叶子节点,且路径之和等于sum if not root.left and not root.right and root.val == sum: return True left_is = False if root.left: left_is = self.hasPathSum(root.left,sum-root.val) right_is = False if root.right: right_is = self.hasPathSum(root.right,sum-root.val) return left_is or right_is Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 16:53:32 "},"二叉树/路径总和 II LeetCode 113.html":{"url":"二叉树/路径总和 II LeetCode 113.html","title":"路径总和 II_LeetCode 113","keywords":"","body":"路径总和 II(LeetCode 113) 1.题目 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5] ] 2.分析 3.代码 def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]: X = [] path = [] self.func(root, sum, path, X) # print(X) return X def func(self, root, sum, path, X): if not root: return sum -= root.val path.append(root.val) if not root.left and not root.right and sum == 0: X.append(path[:]) if root.left: self.func(root.left, sum, path, X) if root.right: self.func(root.right, sum, path, X) # 从root走到叶子节点了，但是路径之和不为sum，所以向上回溯 path.pop() 全局变量可以这么设 def pathSum(self, root, sum): self.res = [] self.track = [] self.helper(root, sum) return self.res def helper(self, node, sum): if not node: return self.track.append(node.val) sum -= node.val if not node.left and not node.right and sum == 0: self.res.append(self.track[:]) else: self.helper(node.left, sum) self.helper(node.right, sum) self.track.pop() Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:25 "},"二叉树/路径总和 III LeetCode 437.html":{"url":"二叉树/路径总和 III LeetCode 437.html","title":"路径总和 III LeetCode_437","keywords":"","body":"路径总和 III(LeetCode 437) 1.题目 给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 2.分析 3.代码 def pathSum(self, root: TreeNode, sum: int) -> int: if root == None: return 0 res = 0 res += self.func(root, sum) # 这个判断可以不要，因为下个函数会判断 if root.left: # 注意这儿的调用，不是func(root.left, sum),因为这样的话，只会统计以root.left为根的左右子树的和是否满足要求。而忽略了以root.left和root.left.left root.left root.left.right加起来和为sum的情况 res += self.pathSum(root.left, sum) if root.right: res += self.pathSum(root.right, sum) # print(res) return res def func(self, root, sum): if root == None: return 0 res = 0 # 这儿不需要判断是不是叶子节点（根据题意） sum -= root.val # if not root.left and not root.right and sum == 0: # 这儿出问题了，不能return 1，因为return 后，下面的代码就不执行了 if sum == 0: # return 1 res += 1 left = self.func(root.left, sum) right = self.func(root.right, sum) return res+left+right class Solution: def pathSum(self, root: TreeNode, sum: int) -> int: if root == None: return 0 res = 0 res += self.func(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum) return res def func(self, root, sum): if root == None: return 0 sum -= root.val if sum == 0: # print(sum) return 1+ self.func(root.left, sum) + self.func(root.right, sum) else: return self.func(root.left, sum) + self.func(root.right, sum) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 00:35:08 "},"二叉树/二叉树的最近公共祖先.html":{"url":"二叉树/二叉树的最近公共祖先.html","title":"二叉树的最近公共祖先","keywords":"","body":"二叉树的最近公共祖先 1.题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 2.分析 有两种情况，一是要找的这两个节点（a, b），在要遍历的节点（root）的两侧，那么这个节点就是这两个节点的最近公共父节点； 二是两个节点在同一侧，则 root->left 或者 root->right 为 NULL，另一边返回a或者b。那么另一边返回的就是他们的最小公共父节点。 递归有两个出口，一是没有找到a或者b，则返回NULL；二是只要碰到a或者b，就立刻返回。 二叉树的很多问题都可以转化为二叉树的遍历来求解 3.代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': if not root: return None if root.val == q.val or root.val == p.val: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) # q,p分布在根结点的两边，则root为最近公共祖先 if left and right: return root # 经过上面的几个if判断后，如果能走到这一步，if left 则说明q,p都在左边，反之else right，则说明q,p都在右边。 # 而且这儿的left，right都是经过递归后的伪根结点。自然就是q，p的公共祖先 return left if left else right class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': if root is None: return None if root.val == q.val or root.val == p.val: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if not right: return left if not left: return right else: return root Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 00:03:01 "},"二叉树/二叉搜索树的最近公共祖先.html":{"url":"二叉树/二叉搜索树的最近公共祖先.html","title":"二叉搜索树的最近公共祖先","keywords":"","body":"二叉搜索树的最近公共祖先 1.题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 2.分析 这是一个非常经典的问题，我们通过递归可以非常快的解决这个问题，我们只要理清楚这样的几种情况： root.val > p.val and root.val > q.val，那我们在root.left继续搜索 root.val 其他的情况，返回root 3.代码 3.1递归版 # 循环版本 def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': if not root: return None # 祖先在左子树 if root.val > q.val and root.val > p.val: return self.lowestCommonAncestor(root.left, p, q) # 祖先在右子树 if root.val q.val and root.val p.val and root.val 3.2跌代版 def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': if root == None: return None while root: if root.val > q.val and root.val > p.val: root = root.left elif root.val Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:34 "},"二叉树/将有序数组转换为二叉搜索树 LeetCode 108.html":{"url":"二叉树/将有序数组转换为二叉搜索树 LeetCode 108.html","title":"将有序数组转换为二叉搜索树_LeetCode 108","keywords":"","body":"将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)(LeetCode 108) 1.题目 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 2.分析 高度差不超过一，说明是二叉搜索树 先取数组中间节点作为根节点，将数组分成左右部分，对数组的左右两部分采用递归的方法进行建立左右子树 时间复杂度（O(n)）: 因为这种方法只遍历了一遍数组，因此，算法的时间复杂度，是O(n) 3.代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def sortedArrayToBST(self, nums: List[int]) -> TreeNode: # 平衡二叉树前序遍历是递增的，列表中间点是根节点 if len(nums) def sortedArrayToBST(self, nums: List[int]) -> TreeNode: # 平衡二叉树前序遍历是递增的，列表中间点是根节点 if len(nums) right: return mid = (left+right) // 2 root = TreeNode(nums[mid]) print(root.val) root.left = self.creat_BST(nums, left, mid-1) root.right = self.creat_BST(nums, mid+1, right) return root Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-11 23:53:56 "},"二叉树/二叉树中的最大路径和 LeetCode 124.html":{"url":"二叉树/二叉树中的最大路径和 LeetCode 124.html","title":"二叉树中的最大路径和_LeetCode 124","keywords":"","body":"二叉树中的最大路径和(LeetCode 124) 1.题目 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 输入: [1,2,3] 1 / \\ 2 3 输出: 6 示例 2: 输入: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 输出: 42 2.分析 3.代码 class Solution: def maxPathSum(self, root): self.re = float('-inf') self.func(root) return self.re def func(self,root): if root == None: return 0 left = max(0,self.func(root.left)) right = max(0,self.func(root.right)) self.re = max(self.re,root.val + left + right) return max(root.val,root.val + max(right,left)) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:34 "},"二叉树/二叉树最大子树和.html":{"url":"二叉树/二叉树最大子树和.html","title":"二叉树最大子树和","keywords":"","body":"二叉树最大子树和 1. 题目 给定一颗二叉树，它的每个节点都是正数或负数，如何找到一颗子树，是的该子树和最大 2. 分析 ​ 要求一棵二叉树的最大子树和，最容易想到的办法就是对每棵子树，求出这棵子树中所有节点的和，然后从中选出最大值。恰好二叉树的后序遍历就能做到这一点，在对二叉树进行后序遍历过程中，如果当前遍历节点的值与其左右子树和的值相加大于最大值，则更新最大值。 3. 代码 class Solution: res = float('-inf') def findMax(self, root, maxroot): if root is not None: left = self.findMax(root.left, maxroot) right = self.findMax(root.right, maxroot) tmp_res = left + right + root.data if tmp_res > self.res: self.res = tmp_res maxroot.data = root.data return self.res else: return 0 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-12 09:50:29 "},"二叉树/判断两棵二叉树是否相等.html":{"url":"二叉树/判断两棵二叉树是否相等.html","title":"判断两棵二叉树是否相等","keywords":"","body":"判断两棵二叉树是否相等 1. 题目 两棵二叉树如果相等，则两棵二叉树有着相同的结构，并且在相同的位置上有相同的值 2. 分析 ​ 如果两棵二叉树root1,root2相等，那么root1与root2节点值相同，同时他们的左右孩子也有相同的结构，且值root1.data == root2.data，根据这个条件，我们可以用递归进行判断 3. 代码 class BiNode(object): def __init__(self, data): self.data = data self.left = None self.right = None def isEqual(root1, root2): if root1 is None and root2 is None: return True if root1 is not None and root2 is None: return False if root1 is None and root2 is not None: return False if root1.data == root2.data: left = isEqual(root1.left, root2.left) right = isEqual(root1.right, root2.right) return left and right else: return False def constructTree(): root1 = BiNode(2) node1 = BiNode(3) node2 = BiNode(4) root.left = node1 root.right = node2 node1.left = node1.right = node2.left= node2.right = None return root if __name__ == '__main__': root1 = constructTree() root2 = constructTree() equal = isEqual(root1, root2) pritn(equal) 4.复杂度分析 ​ 对两棵树只进行了一次遍历，所以时间复杂度为O(n),空间复杂度为O(1) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-12 10:09:53 "},"二叉树/求树的节点数量.html":{"url":"二叉树/求树的节点数量.html","title":"求树的节点数量","keywords":"","body":"求树的节点数量 def countNodes(self, root): # 计算树的节点数 if root == None: return 0 else: return 1 + self.countNodes(root.left) + self.countNodes(root.right) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:23 "},"二叉树/从中序和后序遍历构造二叉树.html":{"url":"二叉树/从中序和后序遍历构造二叉树.html","title":"从中序和后序遍历构造二叉树","keywords":"","body":"从中序与后序遍历序列构造二叉树(LeetCode_106) 1. 题目 根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 2. 分析 3. 代码 def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode: if not inorder: return None mid_data = postorder[-1] root = TreeNode(mid_data) mid = inorder.index(mid_data) root.left = self.buildTree(inorder[:mid], postorder[:mid]) root.right = self.buildTree(inorder[mid+1:], postorder[mid:-1]) return root Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-12 19:37:17 "},"二叉树/二叉搜索树中第K小的元素.html":{"url":"二叉树/二叉搜索树中第K小的元素.html","title":"二叉搜索树中第K小的元素","keywords":"","body":"二叉搜索树中第K小的元素 1.题目 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明： 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1: 输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 输出: 1 示例 2: 输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 输出: 3 2.分析 3.代码1 class Solution(object): def kthSmallest(self, root, k): \"\"\" :type root: TreeNode :type k: int :rtype: int \"\"\" arr = [] def inder(root, arr, k): if root: inder(root.left, arr, k) if len(arr) >= k: # print(root.val) return arr.append(root.val) inder(root.right, arr, k) inder(root, arr, k) # print(arr[-1]) # 必须这样，而不能直接在if语句返回 return arr[-1] return arr[-1] 代码2 class Solution(object): def countNodes(self, root): # 计算树的节点数 if root == None: return 0 else: return 1 + self.countNodes(root.left) + self.countNodes(root.right) def kthSmallest(self, root, k): \"\"\" :type root: TreeNode :type k: int :rtype: int \"\"\" # 先遍历所有的值，然后找到第k小的数字，最后利用二分搜索进行处理 if root == None: return None leftCount = self.countNodes(root.left) if k [!TIP] 计算树的节点数 def countNodes(self, root): if root == None: return 0 else: return 1 + self.countNodes(root.left) + self.countNodes(root.right) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:34 "},"二叉树/二叉树展开为链表.html":{"url":"二叉树/二叉树展开为链表.html","title":"二叉树展开为链表","keywords":"","body":"二叉树展开为链表 1. 题目 给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 1 / \\ 2 5 / \\ \\ 3 4 6 将其展开为： 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 2. 分析 3.代码 递归 class Solution: def flatten(self, root: TreeNode) -> None: \"\"\" Do not return anything, modify root in-place instead. \"\"\" # 前序遍历展开为链表 if root is None: return None if root.left is None and root.right is None: return root self.flatten(root.left) self.flatten(root.right) ltree, rtree = root.left, root.right ltree.left = None p = root.left while p.right: p = p.right p.right = root root.right = rtree 迭代 def flatten(self, root: TreeNode) -> None: if root is None: return None if root.left is None and root.right is None: return root cur = root while cur: if cur.left: p = cur.left while p.right: p = p.right p.right = cur.right cur.right = cur.left cur.left = None cur = cur.right 暴力法 def flatten(self, root): if root is None: return None if root.left is None and root.right is None: return root res = [] def func(root): if root is not None: res.append(root.val) func(root.left) func(root.right) func(root) root.left = None p = root for i in range(1,len(res)): node = TreeNode(res[i]) print(node.val) p.left = None p.right = node p = p.right # i = 1 # root.left = None # p = root # while i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-13 12:20:50 "},"二叉树/二叉树序列化和反序列化.html":{"url":"二叉树/二叉树序列化和反序列化.html","title":"二叉树序列化和反序列化","keywords":"","body":"1.题目 二叉树的序列化和反序列化 2.代码 序列化 # 作者 ：gw # 创建日期 ：2019-07-11 下午 19:31 # 文件名 ：二叉树序列化.py class Node(object): \"\"\"\"\"\" def __init__(self, data): self.data = data self.left = None self.right = None class Bitree(object): def __init__(self,li): self.root = None if li: for i in li: self.add(i) def add(self, val): node = Node(val) if self.root is None: self.root = node return queue = [self.root] while queue: tmp = queue.pop(0) if tmp.left is None: tmp.left = node return else: queue.append(tmp.left) if tmp.right is None: tmp.right = node return else: queue.append(tmp.right) def breadth_travel(self, root): if root is None: return queue = [root] res = [] while queue: tmp = queue.pop(0) res.append(tmp.data) if tmp.left is not None: queue.append(tmp.left) if tmp.right is not None: queue.append(tmp.right) return res def inorder(self, root): if root: self.inorder(root.left) print(root.data, end=\" \") self.inorder(root.right) def serializer(self, root): if root is None: return ['#'] left = self.serializer(root.left) right = self.serializer(root.right) return [root.data] + left + right def Serialize(self, root): if not root: return '#' return str(root.data) + ',' + self.Serialize(root.left) + ',' + self.Serialize(root.right) def deserializer(self, li): if not li: return None data = li.pop(0) root = None if data !='#': root = Node(data) root.left = self.deserializer(li) root.right = self.deserializer(li) return root tree = Bitree([1,2,3,4,5]) # tree.inorder(tree.root) ser = tree.serializer(tree.root) print(ser) ser1 = tree.Serialize(tree.root) print(ser1) root = tree.deserializer([1, 2, 4, '#', '#', 5, '#', '#', 3, '#', '#']) print(tree.breadth_travel(root)) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-11 20:23:54 "},"二叉树/判断一个数组是否是二叉搜索树的后序遍历.html":{"url":"二叉树/判断一个数组是否是二叉搜索树的后序遍历.html","title":"判断一个数组是否是二叉搜索树的后序遍历","keywords":"","body":"题目 1. 判断数组是否是二叉搜索树的后序遍历 ​ 判断一个数组是否是二叉搜索树的后续遍历，如果是，返回True，如果不是,返回False，比如【1，3，2，5，7，6，4】就是一棵二叉搜索树的后序遍历序列。 2. 分析 1. 二叉搜索树的特点：对于任意一个节点，它的左子树上所有节点的值都小于这个节点的值，它的右子树上所有节点都大于这个节点的值。 二叉搜索树后序遍历的特点，列表的最后一个值一定是树的根节点，然后我们可以根据这个根节点将列表前n-1个元素切分为左右子树。然后对切分的左右子树根据左右子树的最后一个节点进行左右切割。 后序遍历为切入点 碰到一个题目，判断一个数组是不是排序二叉树的后序遍历，所谓排序二叉树，指的是对于二叉树中的根节点比左子节点数值大，同时比右子节点数值小，例如[5,7,6,9,11,10,8] 就是一个排序二叉树的后序遍历，而[7,10，8,9]则不是 解题思维： 既然是后序遍历，则数组最后一个数值肯定是根节点，而从左到右，剩下数组元素的左侧值肯定小于根节点值，而其余的数组元素则大于根节点，例如[5,7,6,9,11,10,8]这个数组，8肯定是根节点，而从数组左侧到5~6三个数比8小，肯定是左子树，而剩下的9~10应该就是右子树，右子树应该满足每个数字都比根节点大，如果满足的话，我们再把[5,7,6]和[9,11,10]两个部分的数组元素重复进行之前的操作，知道结束 按照这个思路分析一下[7,10,8,9]为什么不是，首先9为根节点，从数组左侧找到比8小的元素组，该元素组的最后一个元素是7，因此，左子树应该是7，而剩下的[10,8,9]应该是右子树，右子树应该满足的条件是每个数字都比根节点9大，然而8比9小，所以不满足 3. 代码 def is_after_order(li, left, right): if not li: return False mid = li[right] i = left while i mid: break i += 1 j = i while j left: left_is = is_after_order(li, left, i-1) if j class Solution: def VerifySquenceOfBST(self, sequence): # write code here if sequence == None or len(sequence)==0: return False length = len(sequence) root = sequence[-1] # 在二叉搜索树中 左子树节点小于根节点 在序列中找出左子树 i = 0 while i root: break i += 1 # 在二叉搜索树中 右子树节点大于根节点 j = i while j0: left = self.VerifySquenceOfBST(sequence[0:i]) right = True if i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 18:33:33 "},"二叉树/二叉树路径等于输入整数的所有路径.html":{"url":"二叉树/二叉树路径等于输入整数的所有路径.html","title":"二叉树路径等于输入整数的所有路径","keywords":"","body":"给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5] ] 显式回溯 def binaryTreePaths(self, root): sum = 8 X = [] if root is None: return 0 self.helper(root, sum, [] ,X) # return self.res print(X) def helper(self, node, sum, x, X): if not node: return sum -= node.val x.append(node.val) if not node.left and not node.right and sum == 0: X.append(x[:]) return if node.left: self.helper(node.left, sum,x,X) if node.right: self.helper(node.right, sum,x,X) sum += x[-1] x.pop() 隐式回溯 def binaryTreePaths(self, root): sum = 8 X = [] if root is None: return 0 self.helper(root, sum, [root.val] ,X) # return self.res print(X) def helper(self, node, sum, x, X): if not node: return sum -= node.val # x.append(node.val) if not node.left and not node.right and sum == 0: X.append(x[:]) return if node.left: self.helper(node.left, sum,x+[node.left.val],X) if node.right: self.helper(node.right, sum,x+[node.right.val],X) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 00:32:08 "},"二叉树/二叉树的所有路径_LeetCode_257_简单.html":{"url":"二叉树/二叉树的所有路径_LeetCode_257_简单.html","title":"二叉树的所有路径LeetCode_257简单","keywords":"","body":"二叉树的所有路径(LeetCode257简单) 1.题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 1 / \\ 2 3 \\ 5 输出: [\"1->2->5\", \"1->3\"] 解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3 2.分析 显式回溯 隐式回溯 递归 3.代码 In [47]: a = ['2'] In [48]: '->'.join(a) Out[48]: '2' 显式回溯 class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: res = [] self.func(root, [], res) return res def func(self, node, x, res): if node is None: return x.append(str(node.val)) if node.left is None and node.right is None: res.append('->'.join(x)) if node.left: self.func(node.left, x, res) if node.right: self.func(node.right, x, res) x.pop() 隐式回溯 class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: res = [] if root is None: return [] self.func(root, [str(root.val)], res) return res def func(self, node, x, res): if node is None: return if node.left is None and node.right is None: res.append('->'.join(x)) if node.left: self.func(node.left, x+[str(node.left.val)], res) if node.right: self.func(node.right, x+[str(node.right.val)], res) 递归 def binaryTreePaths(self, root: TreeNode) -> List[str]: res = [] # 前面先讨论递归到底的情况情况 if root is None: return res if root.left is None and root.right is None: res.append(str(root.val)) return res # 字符串列表 left_paths = self.binaryTreePaths(root.left) for path in left_paths: res.append(str(root.val) + '->' + path) # 字符串列表 right_paths = self.binaryTreePaths(root.right) for path in right_paths: res.append(str(root.val) + '->' + path) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 00:29:08 "},"二叉树/二叉树的镜像.html":{"url":"二叉树/二叉树的镜像.html","title":"二叉树的镜像","keywords":"","body":"二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 # -*- coding:utf-8 -*- # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: # 返回镜像树的根节点 def Mirror(self, root): if not root: return None root.left, root.right = root.right, root.left if root.left: self.Mirror(root.left) if root.right: self.Mirror(root.right) return root Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 18:23:38 "},"二叉树/判断是否是平衡二叉树_LeetCode_110.html":{"url":"二叉树/判断是否是平衡二叉树_LeetCode_110.html","title":"判断是否是平衡二叉树_LeetCode_110","keywords":"","body":"平衡二叉树(LeetCode_110) 1.题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。 2.分析 对于二叉树，很多题既要判断根节点，还有判断左节点，右节点，这个题也是，如果只判断根节点，就会出错 3.代码 class Solution: def isBalanced(self, root: TreeNode) -> bool: # write code here if not root: return True def func(node): if node is None: return 0 return max(func(node.left),func(node.right))+1 return abs(func(root.left)-func(root.right)) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 19:25:32 "},"动态规划/":{"url":"动态规划/","title":"动态规划","keywords":"","body":"动态规划 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 20:39:29 "},"动态规划/不同路径 LeetCode 62.html":{"url":"动态规划/不同路径 LeetCode 62.html","title":"不同路径_LeetCode 62","keywords":"","body":"不同路径(LeetCode 62) 1.题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：*m 和 n* 的值均不超过 100。 示例 1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -> 向右 -> 向下 2. 向右 -> 向下 -> 向右 3. 向下 -> 向右 -> 向右 示例 2: 输入: m = 7, n = 3 输出: 28 2.分析 动态规划 起始点颠倒 3.代码 动态规划 # 注意：这是n行m列 def uniquePaths(self, m: int, n: int) -> int: mat = [[None]*m for _ in range(n)] for i in range(m): mat[-1][i] = 1 for i in range(n): mat[i][-1] = 1 # for _ in mat: # print(_) for i in range(n-2,-1,-1): for j in range(m-2,-1,-1): mat[i][j] = mat[i][j+1] + mat[i+1][j] # print(mat[0][0]) return mat[0][0] 起始点颠倒 def uniquePaths(self, m, n): mat = [[0]*m for _ in range(n)] for i in range(n): mat[i][0] = 1 for j in range(m): mat[0][j] = 1 print(mat) for i in range(1,n): for j in range(1,m): mat[i][j] = mat[i-1][j] + mat[i][j-1] # print(mat[-1][-1]) return mat[-1][-1] 空间复杂度优化为2m class Solution: def uniquePaths(self, m: int, n: int) -> int: up = [1] * m # 上面一行 now = [1] * m # 下面一行 （当前行） for i in range(1,n): for j in range(1,m): now[j] = up[j] + now[j-1] up = now[:] # 将计算好的值，赋给上一行 return now[-1] 优化空间复杂度 O(n) class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1] * n for i in range(1,m): # dp[0] = dp[0] 可省略，但是不省略含义更明确 for j in range(1,n): dp[j] = dp[j-1] + dp[j] return dp[-1] 排列组合 因为机器到底右下角，向下几步，向右几步的总步数都是固定的， 比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。 所以有 $C_{m+n-2}^{m-1}$ 阶层函数 math.factorial(n) ans = ((m-1 + n-1))!/(m-1)!(n-1)! Cnm = n! / [(n-m)! * m!] def uniquePaths(self, m: int, n: int) -> int: return int(math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1)) 阶层计算函数 from functools import reduce def func(n): return reduce(lambda x,y:x*y, range(1,n+1)) 阶层递归计算函数 def func(n): if n==1: return 1: else: return n*func(n-1) class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for (int i = 0; i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-06 13:57:34 "},"动态规划/不同路径2_LeetCode_63.html":{"url":"动态规划/不同路径2_LeetCode_63.html","title":"不同路径2_LeetCode_63","keywords":"","body":"不同路径 II(LeetCode_63) 1.题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：*m 和 n* 的值均不超过 100。 示例 1: 输入: [ [0,0,0], [0,1,0], [0,0,0] ] 输出: 2 解释: 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -> 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右 2.分析 对第一行第一列特殊处理 在左边和上边各加一条边界 3.代码 特殊处理 class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int: if not obstacleGrid or not obstacleGrid[0]: return 0 row = len(obstacleGrid) col = len(obstacleGrid[0]) if obstacleGrid[0][0] == 1:return 0 dp = [[0]*col for _ in range(row)] dp[0][0] = 1 for i in range(1,row): if obstacleGrid[i][0] == 0: dp[i][0] = dp[i-1][0] for j in range(1,col): if obstacleGrid[0][j] == 0: dp[0][j] = dp[0][j-1] for i in range(1,row): for j in range(1,col): if obstacleGrid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 在左边和上边各加一条边界 class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int: if not obstacleGrid or not obstacleGrid[0]: return 0 if obstacleGrid[0][0]==1: return 0 row = len(obstacleGrid)+1 col = len(obstacleGrid[0])+1 if obstacleGrid[row-2][-1] == 1 or obstacleGrid[-1][col-2]:return 0 dp = [[0]*(col) for _ in range(row)] for i in range(1,row): for j in range(1,col): if i==1 and j==1: if obstacleGrid[i-1][j-1] == 1: return 0 else: dp[1][1] = 1 else: if obstacleGrid[i-1][j-1] == 1: pass else: dp[i][j] = dp[i-1][j]+ dp[i][j-1] return dp[-1][-1] 在左边和上边各加一条边界（简写） class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int: if not obstacleGrid or not obstacleGrid[0]: return 0 if obstacleGrid[0][0]==1: return 0 row = len(obstacleGrid)+1 col = len(obstacleGrid[0])+1 if obstacleGrid[row-2][-1] == 1 or obstacleGrid[-1][col-2]:return 0 dp = [[0]*(col) for _ in range(row)] for i in range(1,row): for j in range(1,col): if i==1 and j==1: dp[1][1] = 1 else: if obstacleGrid[i-1][j-1] == 0: dp[i][j] = dp[i-1][j]+ dp[i][j-1] return dp[-1][-1] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-21 19:56:09 "},"动态规划/分割回文串 LeetCode 131.html":{"url":"动态规划/分割回文串 LeetCode 131.html","title":"分割回文串 LeetCode 131","keywords":"","body":"分割回文串(LeetCode 131) 1.题目 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例: 输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] 2.分析 回溯法 一个字符一个字符累加，这儿是个关键技巧 3.代码 递归、回溯 def partition(self, s): X = [] self.func(s,0,[],X) return X def func(self, s, index, x, X): if index == len(s): X.append(x[:]) else: # 还有着而需要注意回溯思想，我们只需要单条线走通，其它的就交给回溯算法本身去工作 # 一个字符一个字符累加，关键技巧 for i in range(index+1,len(s)+1): if s[index:i] == s[index:i][::-1]: x.append(s[index:i]) self.func(s,i,x,X) x.pop() Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:37 "},"动态规划/分割回文串 II LeetCode 132.html":{"url":"动态规划/分割回文串 II LeetCode 132.html","title":"分割回文串 II_LeetCode 132","keywords":"","body":"分割回文串 II(LeetCode 132) 1.题目 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回符合要求的最少分割次数。 示例: 输入: \"aab\" 输出: 1 解释: 进行一次分割就可将 s 分割成 [\"aa\",\"b\"] 这样两个回文子串。 2.分析 数组nums[i]表示前i字符串最小的分割次数，那么在遍历过程中需要知道j至i的字符串是否为回文串。 动态规划 f(i)=min(f(j)+1) for j in range(i) 动态规划题目，好比数学数列题，由前面的结果推导后面的结果 dp[i]表示前i个字母的最少分割次数,默认为i-1。 当s[a:b]==s[a:b][ ::-1]时，dp[b]=dp[a]+1 一般动态规划元素个数都比数组元素个数多一 最前面一个元素一般为-1，因此dp的默认写法： # 加入s_len =3 dp = [i for i in range(-1,s_len)] # 输出 -1, 0 , 1, 2 dp = [i for i in range(s_len+1)] dp[0] = -1 # 输出 -1, 0 ,0 ,0 ​ 3.代码 def minCut(self, s: str) -> int: if not s: return 0 s_len = len(s) dp = [i for i in range(-1,s_len)] for i in range(1,s_len+1): for j in range(0,i): if s[j:i] == s[j:i][::-1]: dp[i] = min(dp[j]+1, dp[i]) return dp[-1] .assets\\1553930053874.png) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:36 "},"动态规划/单词拆分 LeetCode 139.html":{"url":"动态规划/单词拆分 LeetCode 139.html","title":"单词拆分_LeetCode 139","keywords":"","body":"单词拆分(LeetCode 139) 1.题目 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"] 输出: true 解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。 示例 2： 输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] 输出: true 解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。 注意你可以重复使用字典中的单词。 示例 3： 输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] 输出: false 2.分析 动态规划 就像爬楼梯，一样，要爬到10楼，先看能不能爬到1楼，2楼等 3.代码 动态规划 def wordBreak(self, s: str, wordDict: List[str]) -> bool: if s =='' or len(wordDict) ==0: return False dp = [0]*(len(s)+1) dp[0] = 1 max_stride = max([len(x) for x in wordDict]) for i in range(1,len(s)+1): k = i-max_stride if k>0: for j in range(k,i): if dp[j]==1 and s[j:i] in wordDict: dp[i] = 1 else: for j in range(0,i): if dp[j]==1 and s[j:i] in wordDict: dp[i] = 1 return dp[-1] == 1 动态规划2 def wordBreak(self, s, wordDict): s_len = len(s) dp = [False]*(s_len+1) dp[0] = True # 因为单词长度最小是1，所以起点是1 for i in range(1,s_len+1): for word in wordDict: if i>=len(word) and dp[i-len(word)] and word == s[i-len(word):i]: dp[i] = True return dp[-1] 在上一个动态规划上进行优化 class Solution: def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: bool \"\"\" len_s = len(s) mem = [False]*(len_s+1) mem[0] = True tmpDict = dict((i,len(i)) for i in wordDict) for i in range(1, len_s + 1): for word in wordDict: if i >= tmpDict[word] and mem[i - tmpDict[word]] \\ and word == s[i-tmpDict[word]:i]: mem[i] = True break return mem[-1] 回溯 class Solution: def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: bool \"\"\" return self._wordBreak(s, set(wordDict), 0) def _wordBreak(self, s, words, start): if start == len(s): return True for i in range(start + 1, len(s) + 1): sub = s[start:i] if sub in words and self._wordBreak(s, words, i): return True return False Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:39 "},"动态规划/鸡蛋掉落 Leetcode 887.html":{"url":"动态规划/鸡蛋掉落 Leetcode 887.html","title":"鸡蛋掉落_Leetcode 887","keywords":"","body":"鸡蛋掉落(Leetcode 887) 1.题目 你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。 你知道存在楼层 F ，满足 0 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 ）。 你的目标是确切地知道 F 的值是多少。 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例 1： 输入：K = 1, N = 2 输出：2 解释： 鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。 否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。 如果它没碎，那么我们肯定知道 F = 2 。 因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 示例 2： 输入：K = 2, N = 6 输出：3 示例 3： 输入：K = 3, N = 14 输出：4 提示： 1 1 2.分析 dp[k][m] 的含义是k个鸡蛋 移动m次最多能够确定多少楼层 这个角度思考 dp[k][m] 最多能够确定的楼层数为L 那么我选定第一个扔的楼层之后，我要么碎，要么不碎 这就是把L分成3段 左边是碎的那段 长度是dp[k-1][m - 1] 右边是没碎的那段 长度是dp[k][m - 1] 因为已经碎了一个了 中间是我选定扔的楼层 是1 所以递推公式是 dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1 根据递推公式 如果采用k倒着从大到小计算 就可以只存一行的dp[k] 直接原地更新dp[k] 不影响后续计算 只需要O(K)空间复杂度 O(KlogN) 鸡蛋完全够用的时候 就是走LogN步 最差情况是1个鸡蛋走N步 O(KN) 3.代码 def superEggDrop(self, K, N): dp = [0]*(K+1) m = 0 while dp[K] 暴力法 def superEggDrop(self, K: int, N: int) -> int: if K==1:return N if N==0:return 0 res = [] for i in range(1,N+1): res.append(max(self.superEggDrop(K-1,i-1),self.superEggDrop(K,N-i))) print(res) return min(res) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:25 "},"动态规划/最大正方形 LeetCode 221.html":{"url":"动态规划/最大正方形 LeetCode 221.html","title":"最大正方形_LeetCode 221","keywords":"","body":"最大正方形(LeetCode 221) 1.题目 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 输入: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 输出: 4 2.分析 dpi - 1，dpi 和 dpi - 1 都有可能转移到 dpi 在上图中，我们可以看到以 (i - 1，j - 1) 这个点为右下角的最大正方形的边长为2（红色），以 (i - 1，j) 这个点为右下角的最大正方形的边长为3（绿色），以 (i，j - 1) 这个点为右下角的正方形的边长为1（蓝色），那么以 (i，j) 为右下角的最大正方形的边长应该为多少呢？ 那么 (i - 1，j) 只能往上和往左延伸3个单位，(i，j - 1) 只能往上和往左延伸1单位，(i - 1，j - 1) 只能往上和往左延伸2个单位： dpi = min(dpi，min(dpi - 1，dpi - 1，dpi) + 1) 可以参考最大矩形 ，单调栈 3.代码 C++代码 class Solution { public: int maximalSquare(vector>& matrix) { if (matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(),n = matrix[0].size(),res = 0; vector> dp(m,vector(n,0)); for(int i =0;i python class Solution: def maximalSquare(self, matrix: List[List[str]]) -> int: if len(matrix)==0 or len(matrix[0]) == 0:return 0 m,n = len(matrix),len(matrix[0]) dp = [[0]*n for i in range(m)] res = 0 for i in range(m): if matrix[i][0] == '1': dp[i][0] = 1 res = 1 for j in range(n): if matrix[0][j] == '1': dp[0][j] = 1 res = 1 # 从1行1列开始遍历 for i in range(1,m): for j in range(1,n): if matrix[i][j]=='1': dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1 print(dp[i][j]) res = max(res,dp[i][j]) return res*res python，在里面赋dp的初值 def maximalSquare(self, matrix: List[List[str]]) -> int: if len(matrix)==0 or len(matrix[0]) == 0:return 0 m,n = len(matrix),len(matrix[0]) dp = [[0]*n for i in range(m)] res = 0 # 从0行0列开始遍历 for i in range(m): for j in range(n): if matrix[i][j]=='1': dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1 res = max(res,dp[i][j]) else: dp[i][j]=0 return res*res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 23:03:10 "},"动态规划/最长上升子序列 LeetCode 300.html":{"url":"动态规划/最长上升子序列 LeetCode 300.html","title":"最长上升子序列_LeetCode 300","keywords":"","body":"最长上升子序列(LeetCode 300) 1.题目 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 2.分析 动态规划思路 1、子序列：不要求连续子序列，只要保证元素前后顺序一致即可； 2、上升：这里的“上升”是“严格上升”，类似于 [2, 3, 3, 6, 7] 这样的子序列是不符合要求的； # 动态规划的思路：将 dp 数组定义为：以 nums[i] 结尾的最长上升子序列的长度 # 那么题目要求的，就是这个 dp 数组中的最大者 # 以数组 [10, 9, 2, 5, 3, 7, 101, 18] 为例： # dp 的值： 1 1 1 2 2 3 4 4 替换思路 dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数. 由定义知dp数组必然是一个递增数组 依次判断每个数num将其插入dp数组相应的位置: 1. num > dp[-1], ，执行插入尾部操作，表示num比所有已知递增序列的尾数都大, 将num添加入dp 数组尾部 2. num 3.代码 动态规划 class Solution: def lengthOfLIS(self, nums: List[int]) -> int: size = len(nums) if size nums[j]: dp[i] = max(dp[j] + 1,dp[i]) # 最后要全部走一遍，看最大值 return max(dp) 为什么是 dp[i] = max(dp[j] + 1,dp[i]) 而不是 dp[i] = dp[j]+1 如下 # [1,3,6,7,9,4,10,5,6] 对于4，如果不用max(dp[j]+1,dp[i]),那 # 么dp['4'] 等于3，当求10，dp['10']时候，10>4,则dp['10'] = # dp['4']+1=4,所以最后max(dp),答案为5，而不是6 动态规划替换 class Solution: def lengthOfLIS(self, nums): n = len(nums) if n stack[-1]: stack.append(nums[i]) else: # 不会动递增序列的个数，但是会调整递增序列的值，这儿也可以用二分查找 for j in range(len(stack)): # dp=【1，2，4】 ,nums[i]=3 if nums[i] > stack[j]: continue else: stack[j] = nums[i] # 将数组中的值替换 break return len(stack) # 返回递增序列的长度，就是最长递增子序列 动态规划之二分替换 class Solution: def lengthOfLIS(self, nums): n = len(nums) if n dp[-1]: dp.append(nums[i]) if nums[i] nums[i]: high = mid-1 else: # 不用替换,设置一个标志位，跳过外循环的替换操作 flag = False break if flag == False: flag = True continue dp[low] = nums[i] return len(dp) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:59 "},"动态规划/最小路径和 LeetCode 64.html":{"url":"动态规划/最小路径和 LeetCode 64.html","title":"最小路径和_LeetCode 64","keywords":"","body":"最小路径和(LeetCode 64) 1.题目 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 2.分析 ​ (动态规划1)：时间复杂为o(nm)和空间复杂度为o(nm)。典型的动态规划问题，假设当前已经开始计算si，那么si只可能从si-1+gridi或者si+gridi计算得到，也就是si = min(si-1,si)+gridi。我们需要一个o(nm)额外空间保存已经计算的si的值，我们只需要访问一遍数组即可。因此时间复杂度为o(nm)，空间复杂度为o(n*m)。我们需要特殊处理矩阵中第一行和第一列。因为第一行没有si-1元素，只有si元素。第一列没有si元素，只有si-1元素。 3.代码 动态规划1(原地修改)： def minPathSum(self, grid): if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) # 从1开始，不然0位置会重复计算 for i in range(1,n): grid[i][0] = grid[i-1][0] + grid[i][0] for j in range(1,m): grid[0][j] = grid[0][j-1] + grid[0][j] for i in range(1,n): for j in range(1,m): grid[i][j] = min(grid[i-1][j], grid[i][j-1])+grid[i][j] return grid[-1][-1] def minPathSum(self, grid): if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) for i in range(n): for j in range(m): if i==0 and j>0: grid[i][j] = grid[i][j-1] + grid[i][j] elif j==0 and i>0: grid[i][j] = grid[i-1][j] + grid[i][j] elif i>0 and j>0: grid[i][j] = min(grid[i-1][j], grid[i][j-1])+grid[i][j] return grid[-1][-1] 动态规划2（非原地修改，空间复杂度m*n） def minPathSum(self, grid): if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) mat = [[grid[0][0]]*m]*n for i in range(1,n): mat[i][0] = mat[i-1][0] + grid[i][0] for j in range(1,m): mat[0][j] = mat[0][j-1] + grid[0][j] for i in range(1,n): for j in range(1,m): mat[i][j] = min(mat[i][j-1], mat[i-1][j]) + grid[i][j] return mat[-1][-1] 动态规划3（非原地修改，空间复杂度2*m） (动态规划2)：时间复杂度为o(nm)，空间复杂度为o(m)，此方法需要2m额外空间。当我们求si时，s[i-2]行的元素我们就不再需要，我们只需要s[i-1]行中的元素，我们把s[i-1]行中的元素保存在up数组中，数组的大小为m。我们把s[i]保存在now数组中，当s[i]行的元素计算完毕以后，我们交换up和now数组。因为需要up数组和now数组，且数组的大小都为m，所以我们需要2*m大小的额外空间。 def minPathSum(self, grid): if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) up = [grid[0][0]]*m now = [0] *m for j in range(1,m): up[j] = grid[0][j] + up[j-1] for i in range(1,n): # 计算now【0】 now[0] = grid[i][0] + up[0] for j in range(1,m): # 在这给其他now赋值 now[j] = min(up[j],now[j-1]) + grid[i][j] up = now.copy() return up[-1] 动态规划4（非原地修改，空间复杂度为m） (动态规划3)：时间复杂度为o(nm)，空间复杂度为o(m)，需要m大小的额外空间，注意此方法和方法三的区别，方法三需要2m大小的额外空间，此方法只需要m大小的额外空间，在方法三中我们保存当前行s[i]中的元素，假设我们当前计算si，我们只需要知道si的值即可，不需要保存s[i]行中的元素。每次计算si时，我们需要更新up[j]的值。 class Solution: def minPathSum(self, grid: List[List[int]]) -> int: if not grid or not grid[0]:return 0 n, m = len(grid), len(grid[0]) dp = [0]*m dp[0] = grid[0][0] for i in range(1,m): dp[i] = dp[i-1] + grid[0][i] for i in range(1,n): dp[0] = grid[i][0] + dp[0] for j in range(1,m): dp[j]= min(dp[j],dp[j-1]) + grid[i][j] return dp[-1] ​ java class Solution { public int minPathSum(int[][] grid) { if (grid == null || grid[0].length == 0 || grid[0] == null || grid.length ==0) return 0; int res=0, n=grid.length, m=grid[0].length; int[] dp = new int[m]; dp[0] = grid[0][0]; for (int i = 1; i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-06 14:21:16 "},"动态规划/斐波拉契数列第n项.html":{"url":"动态规划/斐波拉契数列第n项.html","title":"斐波拉契数列第n项","keywords":"","body":"斐波那契数(LeetCode_509) 1.题目 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 给定 N，计算 F(N)。 提示： 0 ≤ N ≤ 30 2.分析 3.代码 def func(n): if N Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-20 07:03:40 "},"动态规划/零钱兑换_LeetCode_322.html":{"url":"动态规划/零钱兑换_LeetCode_322.html","title":"零钱兑换_LeetCode_322","keywords":"","body":"零钱兑换(LeetCode_322) 1.题目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 输入: coins = [1, 2, 5], amount = 11 输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 输入: coins = [2], amount = 3 输出: -1 说明: 你可以认为每种硬币的数量是无限的。 2.分析 完全背包问题 3.代码 # class Solution: # # 递归 # def coinChange(self, coins: List[int], amount: int) -> int: # if amount == 0:return 0 # res = float('inf') # for i in range(len(coins)): # if coins[i]>amount: # continue # tmp = self.coinChange(coins, amount-coins[i]) # if tmp == -1: # continue # res = min(res, tmp+1) # return res if res != float('inf') else -1 # 从上到下 # class Solution: # def coinChange(self, coins: List[int], amount: int) -> int: # memo = [-2]*(amount+1) # return self.func(coins, amount, memo) # def func(self, coins, amount, memo): # if amount == 0:return 0 # res = float('inf') # if memo[amount] != -2: # return memo[amount] # for i in range(len(coins)): # # 金额不可达 # if coins[i]>amount: # continue # tmp = self.func(coins, amount-coins[i], memo) # # 子问题无解 # if tmp==-1: # continue # res = min(res,tmp+1) # # 记录本轮答案 # memo[amount] = res if res != float('inf') else -1 # return memo[amount] class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [amount+1] *(amount+1) dp[0] = 0 for i in range(1,amount+1): for j in coins: if j amount else dp[amount] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 23:26:44 "},"动态规划/打家劫舍_LeetCode_198.html":{"url":"动态规划/打家劫舍_LeetCode_198.html","title":"打家劫舍_LeetCode_198","keywords":"","body":"打家劫舍(LeetCode_198) 1.题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 2.分析 动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num ) 由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值 举例来说：1 号房间可盗窃最大值为 33 即为 dp[1]=3，2 号房间可盗窃最大值为 44 即为 dp[2]=4，3 号房间自身的值为 22 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 55 时间复杂度：O(n),n 为数组长度 3.代码 class Solution: def rob(self, nums: List[int]) -> int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp =[0]*len(nums) dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-2] + nums[i], dp[i-1]) return dp[-1] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-21 20:15:35 "},"动态规划/打家劫舍2_LeetCode_213.html":{"url":"动态规划/打家劫舍2_LeetCode_213.html","title":"打家劫舍2_LeetCode_213","keywords":"","body":"打家劫舍 II(LeetCode_213) 1.题目 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [2,3,2] 输出: 3 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2: 输入: [1,2,3,1] 输出: 4 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 2.分析 分两种情况讨论，偷第一家，最后家就不能偷，不偷第一家，最后家可以选择偷，也可以选择不偷。然后取最大值 3.代码 class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0],nums[1]) res_1 = self.func(nums[1:]) res_2 = self.func(nums[:-1]) return max(res_1,res_2) def func(self, nums): dp = [0]*len(nums) dp[0],dp[1] = nums[0],max(nums[0],nums[1]) for i in range(2,len(nums)): dp[i] = max(dp[i-2]+nums[i],dp[i-1]) return dp[-1] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-21 20:15:27 "},"动态规划/最大子序和_LeetCode_53.html":{"url":"动态规划/最大子序和_LeetCode_53.html","title":"最大子序和_LeetCode_53","keywords":"","body":"最大子序和(LeetCode 53) 1.题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 2.分析 3.代码 动态规划 def FindGreatestSumOfSubArray(self, array): # write code here # 动态规划 a_len = len(array) res = array[0] dp = [0]*a_len for i in range(a_len): dp[i] = max(dp[i-1]+array[i], array[i]) res = max(res, dp[i]) return res 正常解法 class Solution(object): def maxSubArray(self, nums): sum = 0 max_sub_sum = nums[0] for num in nums: sum += num if sum > max_sub_sum: max_sub_sum = sum if sum 动态规划 遍历数组，记录max(nums[i-1] + nums[i], nums[i])（含义为保留前面累加和与以当前元素为开始，哪种更优），即判断后面subarray是否舍去前面的累计加和，并继续遍历下一元素。 最后return加和中最大值。 class Solution: def maxSubArray(self, nums: List[int]) -> int: for i in range(1,len(nums)): nums[i] = max(nums[i],nums[i-1]+nums[i]) return max(nums) 分治法 最大连续子序列是所有连续子序中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{11,-4,13}，最大连续子序列和即为20。 问题解决思路： 现将序列等分为左右两份，则最大子列只可能出现在三个地方： 1整个子序列出现在左半部分 2整个子序列出现在右半部分 3整个子序列跨越中间边界 前两种情况可以用递归求解，而第三种情况则可以将前半部分的最大子序列和（此处的子序列必须包含前半部分的最后一个元素）与后半部分的最大子序列和（此处的子序列必须包含后半部分的第一个元素）相加得到 注1：因为第三种情况跨越了中间边界，且要求的序列为连续的，因此第三种情况得到的子序列必定包含左子序列的最后一个元素以及右子序列的第一个元素。 注2：若要求的序列可以为不连续的，则第三种情况可以直接用前半部分最大子序列和与后半部分最大子序列和相加得到 1.分治法解决 连续 子序列 和最大问题 # 注1：因为第三种情况跨越了中间边界，且要求的序列为连续的，因此第三种情况得到的子序列必定包含左子序列 # 的最后一个元素以及右子序列的第一个元素。 def findMaxSum(li): # 如果问题规模小于等于1，直接解决 if len(li) leftAndMidMax: leftAndMidMax = leftAndMid # 用于包含右边第一个数的累加求和 rightAndMid = 0 # 考虑到存在序列全为负数的情况，因为初始化为负无穷而非0 rightAndMidMax = float('-inf')#包含右边最后一个数的最大序列和 for i in right: rightAndMid += i if rightAndMid > rightAndMidMax: rightAndMidMax = rightAndMid # 计算跨越了中间的序列 的最大和 midMaxSum = leftAndMidMax + rightAndMidMax # 合并 return max(leftMaxSum, midMaxSum, rightMaxSum) A=[2,3,4,1,-1,-7,-3,-7,-6] print(findMaxSum(A)) 2.动态规划解决 连续 子序列 和最大： def findMaxSum(li): # initMax 用于累加求和开始 initMax = 0 MaxSum = float(\"-inf\") for i in li: initMax += i if i > initMax: initMax = i if initMax > MaxSum: MaxSum = initMax return MaxSum A=[1,-2,-2,4] print(findMaxSum(A)) 法2 def maxSubArray(self, nums): sum = 0 max_sub_sum = nums[0] for num in nums: sum += num if sum > max_sub_sum: max_sub_sum = sum if sum 3.分治法解决非连续 子序列 和最大问题 def findMaxSum(li): # 如果问题规模小于等于1，直接解决 if len(li) 4.动态规划解决非连续 子序列 和最大问题 def maxSubArray(nums): sum = 0 max_sub_sum = nums[0] for num in nums: sum += num if sum >= max_sub_sum: max_sub_sum = sum else: sum -= num print(max_sub_sum) A = [-1, 2, -2,-3,-5,9] print(findMaxSum(A)) def maxSubArray(nums): max_sub_sum = nums[0] for i in nums[1:]: if i > 0: if max_sub_sum 最大子序和(LeetCode 53) (子数组) 1.题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 2.分析 使用动态规划 F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变 F（i）=max（F（i-1）+array[i] ， array[i]） res：所有子数组的和的最大值 res=max（res，F（i）） 如数组[6, -3, -2, 7, -15, 1, 2, 2] 初始状态： F（0）=6 res=6 i=1： F（1）=max（F（0）-3，-3）=max（6-3，3）=3 res=max（F（1），res）=max（3，6）=6 i=2： F（2）=max（F（1）-2，-2）=max（3-2，-2）=1 res=max（F（2），res）=max（1，6）=6 i=3： F（3）=max（F（2）+7，7）=max（1+7，7）=8 res=max（F（2），res）=max（8，6）=8 i=4： F（4）=max（F（3）-15，-15）=max（8-15，-15）=-7 res=max（F（4），res）=max（-7，8）=8 以此类推 最终res的值为8 3.代码 class Solution(object): def maxSubArray(self, nums): sum = 0 max_sub_sum = nums[0] for num in nums: sum += num if sum > max_sub_sum: max_sub_sum = sum if sum 动态规划 def FindGreatestSumOfSubArray(self, array): # write code here # 动态规划 a_len = len(array) res = array[0] dp = [0]*a_len for i in range(a_len): dp[i] = max(dp[i-1]+array[i], array[i]) res = max(res, dp[i]) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 12:02:18 "},"动态规划/最长重复子数组_LeetCode_718.html":{"url":"动态规划/最长重复子数组_LeetCode_718.html","title":"最长重复子数组_LeetCode_718","keywords":"","body":"最长重复子数组(LeetCode_718) 1.题目 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 示例 1: 输入: A: [1,2,3,2,1] B: [3,2,1,4,7] 输出: 3 解释: 长度最长的公共子数组是 [3, 2, 1]。 说明: 1 2.分析 动态规划 “子数组”需要连续的一段，并不是“子序列”。 | A \\ B | 空 | 1 | 2 | 1 | | :------: | :--: | :--: | :--: | :--: | | 空 | 0 | 0 | 0 | 0 | | 1 | 0 | 1 | 0 | 1 | | 2 | 0 | 0 | 2 | 0 | | 2 | 0 | 0 | 1 | 0 | dp[i][j] 表示A【:i-1】和B【:j-1】的最长公共子串的长度 初始化： A 为空串时，无论B多少字符，公共连续子序列长度都为0 ：dp[0][j] = 0 B 为空串时，无论A多少字符，公共连续子序列长度都为0 : dp[i][0] = 0 ​ 3.代码 class Solution: def findLength(self, A: List[int], B: List[int]) -> int: s1_len = len(A) s2_len = len(B) max_len = 0 # max_id = 0 mat = [[0]*(s2_len+1) for _ in range(s1_len+1)] for i in range(1,s1_len+1): for j in range(1,s2_len+1): mat[i][j] = mat[i-1][j-1]+ 1 if A[i-1] == B[j-1] else 0 if mat[i][j] > max_len: max_len = mat[i][j] # max_id = i # max_str = s1[max_id-max_len:max_id] return max_len class Solution: def findLength(self, A: List[int], B: List[int]) -> int: s1_len = len(A) s2_len = len(B) max_len = 0 # max_id = 0 mat = [[0]*(s2_len+1) for _ in range(s1_len+1)] for i in range(1,s1_len+1): for j in range(1,s2_len+1): mat[i][j] = mat[i-1][j-1]+1 if A[i-1] == B[j-1] else 0 max_len = max(max_len, mat[i][j]) return max_len Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 10:29:23 "},"动态规划/最长公共子序列.html":{"url":"动态规划/最长公共子序列.html","title":"最长公共子序列","keywords":"","body":"最长公共子序列 A \\ B 空 a b c 空 0 0 0 0 a 0 1 1 1 c 0 1 1 2 b 0 1 2 2 def findMaxSub(s1, s2): s1_len = len(s1) s2_len = len(s2) max_len = 0 max_id = 0 mat = [[0]*(s2_len+1) for _ in range(s1_len+1)] for i in range(1,s1_len+1): for j in range(1,s2_len+1): if s1[i-1] == s2[j-1]: mat[i][j] = mat[i-1][j-1]+1 else: mat[i][j] = max(mat[i][j-1],mat[i-1][j]) print(mat[-1][-1]) findMaxSub('abcdcdabccade', 'dgcadabcdcdde') Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 10:27:18 "},"动态规划/最长公共字符串.html":{"url":"动态规划/最长公共字符串.html","title":"最长公共字符串","keywords":"","body":"def findMaxSub(s1, s2): s1_len = len(s1) s2_len = len(s2) max_len = 0 max_id = 0 mat = [[0]*(s2_len+1) for _ in range(s1_len+1)] for i in range(1,s1_len+1): for j in range(1,s2_len+1): mat[i][j] = mat[i-1][j-1]+1 if s1[i-1] == s2[j-1] else 0 if mat[i][j] > max_len: max_len = mat[i][j] max_id = i max_str = s1[max_id-max_len:max_id] print(max_str,max_len) findMaxSub('abcdcdabccade', 'dgcadabcdcdde') Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 10:27:06 "},"动态规划/正则表达式匹配_LeetCode_10.html":{"url":"动态规划/正则表达式匹配_LeetCode_10.html","title":"正则表达式匹配_LeetCode_10","keywords":"","body":"正则表达式匹配(LeetCode_10) 1.题目 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1: 输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入: s = \"aa\" p = \"a*\" 输出: true 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3: 输入: s = \"ab\" p = \".*\" 输出: true 解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4: 输入: s = \"aab\" p = \"c*a*b\" 输出: true 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 示例 5: 输入: s = \"mississippi\" p = \"mis*is*p*.\" 输出: false 2.分析 思路: 动态规划, 沿着匹配串和字符串构成矩阵的对角线传递状态 1. 状态矩阵的首行与首列对应于空字符与空匹配符 2. 对角线意味着匹配串是否匹配对应的字符串 3.代码 字符串：s串 匹配串：p串 def isMatch(self, s: str, p: str) -> bool: s_len = len(s) p_len = len(p) dp = [[False] *(p_len+1) for _ in range(s_len+1)] # 初始化 # 两串都为空时，算匹配成功 dp[0][0] = True # 匹配串为空串时，字符串1个以上字符时，匹配不成功，即第一列从第一个字符开始为False，由于创建dp # 时候，已经设置好了，所以这儿不用再次初始化 # 当字符串是空串时，匹配串不为空，根据规则, *前必存在一个字符, 则当前为*时, 其状态与前2的状态一致 for i in range(0,p_len): # *出现的位置只能是大于等于1（从0开始计数） # dp和字符串实际位置相差1，所以当前状态p[i]的上上（前2）状态位dp【i-2+1】，都要在dp位置上加1 if p[i] == '*' and dp[0][i-1]: dp[0][i+1] = True for i in range(1,s_len+1): for j in range(1,p_len+1): if p[j-1] == '.' or s[i-1] == p[j-1]: dp[i][j] = dp[i-1][j-1] elif p[j-1] == '*': # 根据匹配规则，比较匹配串*的前一个字符 与 字符串的当前字符 # 二者不相等时，a* 只有作为空串，才能匹配成功 # 也就是，匹配串需要看前两个字符的状态 if p[j-2] != s[i-1]: dp[i][j] = dp[i][j-2] # 两者相等时，a* 可以作为空字符，单字符a，多字符处理 aaa if p[j-2] == s[i-1] or p[j-2] =='.': dp[i][j] = dp[i][j-2] or dp[i][j-1] or dp[i-1][j] return dp[-1][-1] 回溯法 class Solution: def isMatch(self, s: str, p: str) -> bool: ''' 回溯算法: 从后往前匹配, 一旦遇到 *，前面必然有个字符 ''' def match(ins,inp): if inp==-1: if ins==-1: return True return False if p[inp] == '*': # * 匹配多个字符（>=1个字符） if ins>-1 and (p[inp-1] == s[ins] or p[inp-1]=='.'): if match(ins-1,inp): return True # * 匹配0个字符 return match(ins,inp-2) if ins >-1 and(p[inp]==s[ins] or p[inp]=='.'): return match(ins-1,inp-1) return False return match(len(s)-1,len(p)-1) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-21 17:48:11 "},"动态规划/通配符匹配_LeetCode_44.html":{"url":"动态规划/通配符匹配_LeetCode_44.html","title":"通配符匹配_LeetCode_44","keywords":"","body":"通配符匹配(LeetCode_44) 1.题目 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。 '?' 可以匹配任何单个字符。 '*' 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1: 输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入: s = \"aa\" p = \"*\" 输出: true 解释: '*' 可以匹配任意字符串。 示例 3: 输入: s = \"cb\" p = \"?a\" 输出: false 解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。 示例 4: 输入: s = \"adceb\" p = \"*a*b\" 输出: true 解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 \"dce\". 示例 5: 输入: s = \"acdcb\" p = \"a*c?b\" 输入: false 2.分析 参考正则表达式匹配_LeetCode_10 3.代码 class Solution: def isMatch(self, s: str, p: str) -> bool: n, m = len(s),len(p) dp = [[False]*(m+1) for _ in range(n+1)] dp[0][0] = True # 也可以for i in range（m）: ... for i in range(1,m+1): if p[i-1] == '*': dp[0][i] = dp[0][i-1] for i in range(1,n+1): for j in range(1,m+1): if s[i-1] == p[j-1] or p[j-1] =='?': dp[i][j] = dp[i-1][j-1] elif p[j-1] == '*': # * 匹配空字符，多字符 dp[i][j] = dp[i][j-1] or dp[i-1][j] return dp[-1][-1] 回溯 class Solution: def isMatch(self, s: str, p: str) -> bool: def match(ins,inp): if inp == -1: if ins ==-1: return True return False if p[inp] == '*': if ins >-1 and(p[inp-1]==s[ins] or p[inp-1]=='?'): if match(ins-1,inp): return True return match(ins,inp-1) if ins>-1 and (p[inp]==s[ins] or p[inp]=='?'): return match(ins-1,inp-1) return False return match(len(s)-1,len(p)-1) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-21 17:59:57 "},"动态规划/乘积最大子序列 LeetCode 152.html":{"url":"动态规划/乘积最大子序列 LeetCode 152.html","title":"乘积最大子序列 LeetCode 152","keywords":"","body":"乘积最大子序列(LeetCode 152) 1.题目 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 2.分析 一种方法类似于最大前缀和 另外一种方法，我们要保存前面走过的路，里面的最大最小值，因为这是乘法，乘法的话，会出现最大值，是由两个负数乘起来的。但是负数是最小的 3.代码 最大前缀和 # 先计算从左到右的相乘的最大值，再计算从右到左的最大值；再将两组最大值相比 # def maxProduct(self, A): B = A[::-1] for i in range(1, len(A)): # 输入[-3,0,1,-2] # 不加 or 1，输出[-3, 0, 0, 0] [-2, -2, 0, 0] # 所以我们要把A【i】等于0时，置为1 A[i] *= (A[i - 1] or 1) B[i] *= (B[i - 1] or 1) print(A,B) return max(max(A),max(B)) 保留前面计算过的最大最小值 def maxProduct(self, nums: List[int]) -> int: # 由于有正负，所以每次相乘完毕后，应该保留最大和最小值，也就是最大正数，最小负数 maxnum = nums[0] minnum = nums[0] res = nums[0] for i in nums[1:]: print(i) maxnum_temp = maxnum minnum_temp = minnum # 1,-2,i=3，这一次来的数是i=3，则这次的最大，应该就是它自己，不需要乘以前面的最大或者最小 maxnum = max(i, i*maxnum_temp, i*minnum_temp) minnum = min(i, i*maxnum_temp, i*minnum_temp) res = max(res,maxnum) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:30 "},"动态规划/编辑距离_LeetCode_72.html":{"url":"动态规划/编辑距离_LeetCode_72.html","title":"编辑距离_LeetCode_72","keywords":"","body":"编辑距离 1.题目 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1: 输入: word1 = \"horse\", word2 = \"ros\" 输出: 3 解释: horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e') 示例 2: 输入: word1 = \"intention\", word2 = \"execution\" 输出: 5 解释: intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u') 2.分析 3.代码 class Solution: def minDistance(self, word1: str, word2: str) -> int: len1 = len(word1) len2 = len(word2) dp = [[0]*(len2+1) for i in range(len1+1)] for i in range(1,len1+1): dp[i][0] = i for j in range(1,len2+1): dp[0][j] = j # 建立数组dp[][]来存储 以word1[i]为结尾的字符串 转换成 以word2[j]为结尾的字符串 所需的最小操作数 # 1、替换 word1[i] 把 word1[i] 替换成 word2[j] 需要 dp[i-1][j-1]+1步 # 2、删除 word1[i] 把 word1[i] 删除成 word1[i-1] 需要 dp[i][j-1]+1步 # 3、删除 word2[j] 把 word2[j] 删除成 word2[j-1] 需要 dp[i-1][j]+1步(增加word1和删除word2一个效果) # print(dp) for i in range(1,len1+1): for j in range(1,len2+1): if word1[i-1]==word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1) return dp[-1][-1] # 我们需要进行插入、删除和修改操作将A串变为B串，定义c0，c1，c2分别为三种操作的代价 for i in range(1,len1+1): for j in range(1,len2+1): if word1[i-1]==word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j]+c0,dp[i][j-1]+c1,dp[i-1][j-1]+c2) return dp[-1][-1] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-11 15:40:32 "},"动态规划/不同的子序列_LeetCode_940.html":{"url":"动态规划/不同的子序列_LeetCode_940.html","title":"不同的子序列_LeetCode_940","keywords":"","body":"不同的子序列 II(LeetCode940困难) 1.题目 给定一个字符串 S，计算 S 的不同非空子序列的个数。 因为结果可能很大，所以返回答案模 10^9 + 7. 示例 1： 输入：\"abc\" 输出：7 解释：7 个不同的子序列分别是 \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", 以及 \"abc\"。 示例 2： 输入：\"aba\" 输出：6 解释：6 个不同的子序列分别是 \"a\", \"b\", \"ab\", \"ba\", \"aa\" 以及 \"aba\"。 示例 3： 输入：\"aaa\" 输出：3 解释：3 个不同的子序列分别是 \"a\", \"aa\" 以及 \"aaa\"。 提示： S 只包含小写字母。 1 2.分析 我们假设子序列可以为空，最后的结果减一就可以得到正确答案，dp[i]表示数组前i项构成的不同子序列个数， 初始值dp[0] ,前0个构成的子序列个数，‘’ == 1. ===>dp[0] =1 如果数列第i项没有在之前出现过，那么dp[i] = dp[i-1]*2+1 如果数列第i项在之前出现过，那么我们需要找到第i项对应的字符在前i-1个字符出现的最近位置。即0 3.代码 def distinctSubseqII(self, S: str) -> int: s_len = len(S) dp = [0] * (s_len+1) dp[0] = 1 history = {} for i,k in enumerate(S, start = 1): print(i,k) tmp = history.get(S[i-1],None) if tmp is None: dp[i] = dp[i-1]*2 else: dp[i] = 2*dp[i-1] - dp[tmp-1] history[S[i-1]] = i # print(dp) return dp[-1] -1 # 用动态规划先求出包括空序列的所有子序列，再返回答案之前再减去空序列。 class Solution(object): def distinctSubseqII(self, S): dp = [1] last = {} for i, x in enumerate(S): dp.append(dp[-1] * 2) if x in last: dp[-1] -= dp[last[x]] last[x] = i return (dp[-1] - 1) % (10**9 + 7) def distinctSubseqII(self, S): s_len = len(S) dp = [1] * (s_len+1) history = {} for i,k in enumerate(S): dp[i+1] = dp[i]*2 if k in history: dp[i+1] -= dp[history[k]] history[k] = i return (dp[-1] - 1) % (10**9 + 7) 实现上，我们需要建立一个26大小的数组以容纳不同字母结尾的字符串个数。每当我们遍历到一个新的字母时， 此时我们只要将数组中所有结果加起来然后再加1即为以新的字母为结尾的字符串总数。最后我们只要将数组中的结果加起来即可。 def distinctSubseqII(self, S: str) -> int: res = [0]*26 for i in S: res[ord(i)-97] = sum(res) + 1 return sum(res) % (10**9 + 7) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-11 15:57:57 "},"动态规划/解码方法_LeetCode_91.html":{"url":"动态规划/解码方法_LeetCode_91.html","title":"解码方法_LeetCode_91","keywords":"","body":"解码方法(LeetCode_91) 1.题目 一条包含字母 A-Z 的消息通过以下方式进行了编码： 'A' -> 1 'B' -> 2 ... 'Z' -> 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 输入: \"12\" 输出: 2 解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。 示例 2: 输入: \"226\" 输出: 3 解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。 2.分析 动态规划： dp【n】表示n个字符可编码数， 如果s【n-1】!= '0' , 则dp 【n】= dp【n-1】 如果s【n-2】,s【n-1】 组合成的数字是10~26，则dp【n】 = dp【n-1】+dp【n-2】 3.代码 def numDecodings(self, s: str) -> int: if s == '' or s[0] == '0': return 0 s_len = len(s) dp = [0] *(s_len+1) dp[0] = dp[1] = 1 for i in range(2, s_len+1): if s[i-1] != '0': dp[i] += dp[i-1] if s[i-2] == '1' or (s[i-2] =='2'and s[i-1] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 15:58:03 "},"动态规划/最长递增子序列的个数_LeetCode_673.html":{"url":"动态规划/最长递增子序列的个数_LeetCode_673.html","title":"最长递增子序列的个数_LeetCode_673","keywords":"","body":"最长递增子序列的个数(LeetCode_673) 1.题目 给定一个未排序的整数数组，找到最长递增子序列的个数。 示例 1: 输入: [1,3,5,4,7] 输出: 2 解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。 示例 2: 输入: [2,2,2,2,2] 输出: 5 解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。 2.分析 做这道题目之前，建议先去看看300号问题，本题在300号问题的基础上做了一些改变，需要多使用一个数组来记录LIS的组合数 3.代码 class Solution: def findNumberOfLIS(self, nums: List[int]) -> int: n = len(nums) if nnums[j]: # 如果j位的数值比i位小，则可加入i位的LIS比较队列 # dp[i] = max(dp[i], dp[j]+1) if dp[i]dp[j]+1:不需要做任何调整 ans = 0 tmp = max(dp) for i in range(n): if dp[i] == tmp: ans += dp_nums[i] return ans Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 11:15:42 "},"动态规划/最长连续递增序列_LeetCode_674.html":{"url":"动态规划/最长连续递增序列_LeetCode_674.html","title":"最长连续递增序列_LeetCode_674","keywords":"","body":"最长连续递增序列 1.题目 给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例 1: 输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2: 输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。 注意：数组长度不会超过10000。 2.分析 要求时间复杂度为O（n） 3.代码 动态规划 class Solution: def findLengthOfLCIS(self, nums: List[int]) -> int: n = len(nums) if nnums[i-1]: dp[i] = dp[i-1]+1 return max(dp) class Solution: def findLengthOfLCIS(self, nums: List[int]) -> int: nums_len = len(nums) if len(nums)nums[i-1]: count += 1 res = max(res, count) else: count = 1 return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 12:07:40 "},"逻辑思维/":{"url":"逻辑思维/","title":"逻辑思维","keywords":"","body":"逻辑思维 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-08 00:43:19 "},"逻辑思维/Nim Game.html":{"url":"逻辑思维/Nim Game.html","title":"Nim Game","keywords":"","body":"Nim Game 1.题目 一张纸上，画若干条线，双方一人划一次，每次划掉1~3条线。可以选择画1条，也可以划2条，也可以3条。具体划去几条线完全看自己的策略。谁划掉最后一条线，就是赢家。 现在你作为先手，在线条总数为多少的时候，你必赢呢，又在多少的时候必输呢？ 可不可以用一个函数来判断在线条总是为x时你的输赢情况呢？这样你以后跟别人玩这个游戏的时候就不会输啦。 2.分析 每人每步最多划三条线，所以线的总是至少为4条。当线的总数为4条的时候，不管先手划几条线，后手都有应对的方法，先手必输。 所以你会发现8条也是必输，8条线可以分成两个部分，每个部分四条线。自然先手还是必输。4这个数字还真是不太吉利。 当线的总数为5条的时候，先手先划掉一条线，后手就等于是在4条线的情况下先手，自然后手输。 而6条 7条 先手都可以划掉2条线和3条线来让后手落入“4”的陷阱。 所以我们可以看出，我们只要远离”4“就行了。当线的总数不是4的倍数的时候，先手必赢。 看到这里，恭喜你掌握了必胜法则，下次各位盆宇就可以用这个游戏跟别人打赌了。 3.代码 return n%4 == 0 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 00:03:12 "},"逻辑思维/爬楼梯.html":{"url":"逻辑思维/爬楼梯.html","title":"爬楼梯","keywords":"","body":"爬楼梯 1.题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 2.分析 自底向上的动态规划 3.代码 def climbStairs(self, n: int) -> int: a, b = 0, 1 for i in range(n): a, b = b, a+b return b # 法二 # if n==1: # return 1 # if n == 2: # return 2 # a, b = 1, 2 # for i in range(2,n): # a, b = b, a+b # return b 超时算法 def climbStairs(self, n: int) -> int: 法一：超时 if n==1: return 1 if n == 2: return 2 return self.climbStairs(n-1) + self.climbStairs(n-2) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:37:13 "},"逻辑思维/乘积最大子序列 LeetCode 152.html":{"url":"逻辑思维/乘积最大子序列 LeetCode 152.html","title":"乘积最大子序列_LeetCode 152","keywords":"","body":"乘积最大子序列(LeetCode 152) 1.题目 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 2.分析 一种方法类似于最大前缀和 另外一种方法，我们要保存前面走过的路，里面的最大最小值，因为这是乘法，乘法的话，会出现最大值，是由两个负数乘起来的。但是负数是最小的 3.代码 最大前缀和 # 先计算从左到右的相乘的最大值，再计算从右到左的最大值；再将两组最大值相比 # def maxProduct(self, A): B = A[::-1] for i in range(1, len(A)): # 输入[-3,0,1,-2] # 不加 or 1，输出[-3, 0, 0, 0] [-2, -2, 0, 0] # 所以我们要把A【i】等于0时，置为1 A[i] *= (A[i - 1] or 1) B[i] *= (B[i - 1] or 1) print(A,B) return max(max(A),max(B)) 保留前面计算过的最大最小值 def maxProduct(self, nums: List[int]) -> int: # 由于有正负，所以每次相乘完毕后，应该保留最大和最小值，也就是最大正数，最小负数 maxnum = nums[0] minnum = nums[0] res = nums[0] for i in nums[1:]: print(i) maxnum_temp = maxnum minnum_temp = minnum # 1,-2,i=3，这一次来的数是i=3，则这次的最大，应该就是它自己，不需要乘以前面的最大或者最小 maxnum = max(i, i*maxnum_temp, i*minnum_temp) minnum = min(i, i*maxnum_temp, i*minnum_temp) res = max(res,maxnum) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:36:00 "},"逻辑思维/三个数的最大乘积 LeetCode 628.html":{"url":"逻辑思维/三个数的最大乘积 LeetCode 628.html","title":"三个数的最大乘积_LeetCode 628","keywords":"","body":"三个数的最大乘积 LeetCode 628 1.题目 给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1: 输入: [1,2,3] 输出: 6 示例 2: 输入: [1,2,3,4] 输出: 24 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 2.分析 先排好序 然后取最大的3个数相乘，或者最小的两个数（负数）和最大的一个数相乘 3.代码 class Solution: def maximumProduct(self, nums: List[int]) -> int: nums.sort() return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3]) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:29 "},"逻辑思维/买卖股票的最佳时机 LeetCode 121.html":{"url":"逻辑思维/买卖股票的最佳时机 LeetCode 121.html","title":"买卖股票的最佳时机_LeetCode 121","keywords":"","body":"买卖股票的最佳时机(LeetCode 121) 1.题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 2.分析 3.代码 def maxProfit(self, prices: List[int]) -> int: if len(prices) == 0: return 0 # 动态规划，一般都要设这两个变量 result = 0 min_price = prices[0] for price in prices[1:]: result = max(result,price-min_price) min_price = min(min_price,price) print(result) return result 自写 def maxProfit(self, prices): if len(prices) == 0: return 0 res = 0 min_price = prices[0] for i in prices[1:]: res = max(res, i-min_price) if i Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:30 "},"逻辑思维/买卖股票的最佳时机 II LeetCode 122.html":{"url":"逻辑思维/买卖股票的最佳时机 II LeetCode 122.html","title":"买卖股票的最佳时机 II_LeetCode 122","keywords":"","body":"买卖股票的最佳时机 II(LeetCode 122) 1.题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 2.分析 自己手写代码 动态规划 3.代码 自己写 def maxProfit(self, prices): if len(prices)==0: return 0 res = 0 min_price = prices[0] for i in prices[1:]: if i-min_price>0: res += (i-min_price) # 这一步是关键，卖出之后我们必须调整，初始进价 min_price = i # print(res) # 这一步是基本操作 if i 动态规划 def maxProfit(self, prices: List[int]) -> int: # 当明天的价格比今天的价格贵的时候我们今天买，明天卖，这样能够获取最大利润。 if len(prices) == 0: return 0 result = 0 for i in range(len(prices)-1): if prices[i] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:30 "},"逻辑思维/两数相加.html":{"url":"逻辑思维/两数相加.html","title":"两数相加","keywords":"","body":"两数相加 1.题目 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 2.分析 3.代码 def addTwoNumbers(self, l1, l2): cur = ret = ListNode(0) add = 0 while l1 or l2 or add: val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + add add = val // 10 cur.next = ListNode(val % 10) cur = cur.next l1 = l1.next if l1 else None l2 = l2.next if l2 else None return ret.next Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:29 "},"逻辑思维/两数相加-链表 LeetCode 2.html":{"url":"逻辑思维/两数相加-链表 LeetCode 2.html","title":"两数相加-链表 LeetCode 2","keywords":"","body":"两数相加-链表（LeetCode 2） 1.题目 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 2.分析 3.代码 def addTwoNumbers(self, l1, l2): cur = ret = ListNode(0) add = 0 while l1 or l2 or add: val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + add add = val // 10 cur.next = ListNode(val % 10) cur = cur.next l1 = l1.next if l1 else None l2 = l2.next if l2 else None return ret.next Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:35:37 "},"逻辑思维/盛最多水的容器.html":{"url":"逻辑思维/盛最多水的容器.html","title":"盛最多水的容器","keywords":"","body":"盛最多水的容器 1.题目 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 输入: [1,8,6,2,5,4,8,3,7] 输出: 49 2.分析 参照这 Leetcode 125: 验证回文串、 Leetcode 344: 验证回文串、 Leetcode 167: 两数之和 II - 输入有序数组、 Leetcode 345: 反转字符 串中的元音字母几篇文章中的解题思路。我们通过设置两个指针，分别指向数组的头l和尾r，计算容器可以容纳多少水contain。 我们知道想要容乃的水最多，最好的情况是l和r都是最大，然后二者离的最远，但是这是理想情况，我们最一般的情况是二者离的足够远，但是二者都不是很大,二者都很大，但是二者离的近 所以我们一开始从两边考虑就是考虑的第一种可能。如果这个时候num[l] num[r]，我们就需要将r--。而num[l] == num[r]，l++或者r--都可以。 3.代码 def maxArea(self, height: 'List[int]') -> 'int': # 不知道比较次数的，不能用for循环，用while循环 left = 0 right = len(height) - 1 max_area = 0 while left Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 23:37:56 "},"逻辑思维/摩尔投票算法.html":{"url":"逻辑思维/摩尔投票算法.html","title":"摩尔投票算法","keywords":"","body":"摩尔投票算法 假设有这样一个场景：票选村长，每人可投一票，我们将候选村长从1开始编号，村民们在票上写上候选村长的编号即可完成投票。那么最后统计的票可形成一个整型数组。那么谁是村长呢？票数过半的那个人。 摩尔投票算法可以快速的计算出一个数组中出现次数过半的数即大多数（majority），算法核心思想是同加，异减。我们举个例子。 假设数组是：[1,2,1,1,2,1]。算法步骤如下： 1。当前大多数是1，得分置1 2。与当前大多数不同，得分 - 1，得分为0，当前大多数 = 1 1。与当前大多数不同，得分为0，所以设置当前大多数 1 -> 1，得分置1 1。与当前大多数相同，得分 + 1，得分为2，当前大多数 = 1 2。与当前大多数不同，得分 - 1 ，得分为1，当前大多数 = 1 1。与当前大多数相同，得分 + 1，得分为2，当前大多数 = 1 这意味着1是这个数组中出现次数过半的数。 可以感受得到，算法会保存一个当前大多数，和得分，当遇到一个数不是当前大多数时，得分会减一，当减到0时，大多数会发生改变，并且重置得分为1。 这里需要区分的是，摩尔算法不能用来得到众数（mode），例如数组：[1,1,1,2,2,3,3,4,4]，摩尔算法得出最后的结果应该是4，但4并不是众数，可是显然4也不是大多数，那是因为，大多数是指出现次数过半的数，而这个数组中没有这样的数，所以摩尔算法是是失效的，对于这种情况采取需要重新投票。 出现次数超过一半的数 LeetCode原题：169. Majority Element 这里要求出现次数大于一半，所以直接套用摩尔投票算法即可得到答案。 class Solution(object): def majorityElement(self, nums): a, ca = None, 0 for n in nums: if a == n : ca += 1 elif ca == 0: a, ca = n, 1 else : ca -= 1 return a 出现次数超过数组1/3长 LeetCode原题：229. Majority Element II 还能用摩尔投票法吗？答案当然是要，但是需要变通一下。 需要注意的是出现次数超过1/3数组长的数，也许会有多个，例子如下： [1,1,1,2,2,2,3,3]，数组1/3长=2（向下取整），所以1和2都是符合条件的。 但最多只能是2个，证明如下： 证明 : 90个数31个1，31个2，其余数字随便，也就是接近边界时，最多才两个满足条件：1，2 综上，一个数组中不可能存在2个以上的数它们出现的次数大于n/3。 回到题目 如果我们在使用摩尔算法时，同时记录两个大多数，会怎么样呢？直觉告诉我，这会得到一个大多数，和一个出现次数仅次于大多数的数，但是这两个数不一定会比数组长的1/3大 所以我们得到它们后，还需要检查它们出现的次数是否符合条件。 def majorityElement(self, nums): a, b, ca, cb, ans = None, None, 0, 0, [] for i in nums: if i == a: ca += 1 elif i == b: cb += 1 elif ca == 0: a, ca = i, 1 elif cb == 0: b, cb = i, 1 else: ca, cb = ca - 1, cb - 1 print(a, b) ca, cb = 0, 0 for i in nums: if i == a: ca += 1 elif i == b: cb += 1 if ca > len(nums)//3: ans.append(a) if cb > len(nums)//3: ans.append(b) return ans 思路一：数组排序后，如果符合条件的数存在，则一定是数组中间那个数。（比如：1，2，2，2，3；或2，2，2，3，4；或2，3，4，4，4等等） 这种方法虽然容易理解，但由于涉及到快排sort，其时间复杂度为O(NlogN)并非最优； class Solution { public: int MoreThanHalfNum_Solution(vector numbers) { // 因为用到了sort，时间复杂度O(NlogN)，并非最优 if(numbers.empty()) return 0; sort(numbers.begin(),numbers.end()); // 排序，取数组中间那个数 int middle = numbers[numbers.size()/2]; int count=0; // 出现次数 for(int i=0;inumbers.size()/2) ? middle : 0; } }; Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 09:03:16 "},"逻辑思维/最大数 LeetCode 179 数字拼接后最大.html":{"url":"逻辑思维/最大数 LeetCode 179 数字拼接后最大.html","title":"最大数 LeetCode 179 数字拼接后最大","keywords":"","body":"最大数(LeetCode 179)-(数字拼接后最大) 1.题目 给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 输入: [10,2] 输出: 210 示例 2: 输入: [3,30,34,5,9] 输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 2.分析 首先现将数字转化为字符 判断x+y 和 y+x谁大 1. if x+y>y+x: 则不交换 比如2，1 ： 21>12 (字符串拼接比较哦) 1..if x+ypython：(内置排序方法) class Solution: # 自定义排序算法 def largestNumber(self, nums: List[int]) -> str: if sum(nums) == 0: return '0' from functools import cmp_to_key def func(x,y): if x+yy+x: return -1 else: return 0 arr = map(str, nums) res = sorted(arr, key=cmp_to_key(func)) # print(res) return ''.join(res) python：自定义排序方法——》冒泡排序 原始数据：1，2，4，3 转化为char后再排序： 第一趟冒泡：2，4，3，1 第二趟冒泡：4，3，2，1 第三趟冒泡：4，3，2，1 没有发生交换，排序结束 将排序好的数据，拼接成字符串 def largestNumber(self, nums: List[int]) -> str: if sum(nums) == 0: return '0' nums = list(map(str,nums)) for i in range(len(nums)-1): #如果某一趟不冒泡了没有发生交换过程），就代表排好序了， exchange = False for j in range(len(nums)-i-1): if nums[j+1]+nums[j]>nums[j]+nums[j+1]: nums[j+1],nums[j] = nums[j],nums[j+1] exchange = True if not exchange: break return ''.join(nums) 3.代码 如2 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 11:53:59 "},"逻辑思维/最小编辑距离.html":{"url":"逻辑思维/最小编辑距离.html","title":"最小编辑距离","keywords":"","body":"最小编辑距离 1.题目 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1: 输入: word1 = \"horse\", word2 = \"ros\" 输出: 3 解释: horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e') 示例 2: 输入: word1 = \"intention\", word2 = \"execution\" 输出: 5 解释: intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u') 2.分析 3.代码 def minDistance(self, word1, word2): word1_len, word2_len = len(word1), len(word2) if word1_len == word2_len == 0: return 0 if word1_len == None: return word2_len if word2_len == None: return word1_len mem = [[0]*(word2_len+1) for _ in range(word1_len+1)] for i in range(1, word1_len+1): mem[i][0] = i for j in range(1, word2_len+1): mem[0][j] = j for i in range(1, word1_len+1): for j in range(1, word2_len+1): # 注意：这儿为什么是word1[i-1],而不是word1[i],是因为这是对于字符串而言的，而不是矩阵 mem[i][j] = min(mem[i-1][j-1]+(word1[i-1]!=word2[j-1]), mem[i][j-1]+1, mem[i-1][j]+1) # for _ in mem: # print(_) return mem[-1][-1] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:59 "},"逻辑思维/分发糖果_LeetCode_135.html":{"url":"逻辑思维/分发糖果_LeetCode_135.html","title":"分发糖果_LeetCode_135","keywords":"","body":"分发糖果(LeetCode_135) 1.题目 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？ 那么这样下来，老师至少需要准备多少颗糖果呢？ 示例 1: 输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2: 输入: [1,2,2] 输出: 4 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 2.分析 ... 3.代码 class Solution(object): def candy(self, ratings): \"\"\" :type ratings: List[int] :rtype: int \"\"\" n = len(ratings) res = n arr = [0] * n # 先正序遍历，如果后一位比前一位高分，就给比前一位多1的糖果，否则给1 for i in range(1,n): if ratings[i]>ratings[i-1]: arr[i] = arr[i-1]+1 # 在倒叙遍历，如果前一位比后一位高分并且得到的糖果小于或等于后一位，就给前一位孩子比后一位孩子多一个糖果 # [1,2,3,99,8,7,6,5,4,3,2,1] 99就是上面的特殊情况 99的糖果数应该为8的糖果数+1 for j in range(n-2,-1,-1): if ratings[j]>ratings[j+1] and arr[j] 优化 class Solution(object): def candy(self, ratings): \"\"\" :type ratings: List[int] :rtype: int \"\"\" n = len(ratings) res = n arr = [0] * n # 先正序遍历，如果后一位比前一位高分，就给比前一位多1的糖果 for i in range(1,n): if ratings[i]>ratings[i-1]: arr[i] = arr[i-1]+1 # 倒序过程中,统计数量 res += arr[-1] # 在倒叙遍历，如果前一位比后一位高分并且得到的糖果小于或等于后一位，就给前一位孩子比后一位孩子多一个糖果 for j in range(n-2,-1,-1): if ratings[j]>ratings[j+1] and arr[j] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 10:09:32 "},"逻辑思维/岛屿周长_LeetCode_463.html":{"url":"逻辑思维/岛屿周长_LeetCode_463.html","title":"岛屿周长_LeetCode_463","keywords":"","body":"岛屿的周长 1.题目 给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 : 输入: [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] 输出: 16 解释: 它的周长是下面图片中的 16 个黄色的边： 2.分析 3.代码 def islandPerimeter(self, grid: List[List[int]]) -> int: res = 0 row, col = len(grid), len(grid[0]) for i in range(row): for j in range(col): if grid[i][j] == 1: res += 4 if i>0 and grid[i-1][j] == 1: res -= 2 if j>0 and grid[i][j-1] == 1: res -= 2 return res # 由于岛屿内没有湖,所以只需要求出 北面(或南面) + 西面(或东面)的长度再乘2即可 def islandPerimeter(self, grid: List[List[int]]) -> int: res = 0 row, col = len(grid), len(grid[0]) for i in range(row): for j in range(col): if grid[i][j] == 1: if i==0 or grid[i-1][j] == 0: res += 1 if j==0 or grid[i][j-1] == 0: res += 1 return res * 2 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 16:05:32 "},"逻辑思维/三维形体的表面积_LeetCode_892.html":{"url":"逻辑思维/三维形体的表面积_LeetCode_892.html","title":"三维形体的表面积_LeetCode_892","keywords":"","body":"三维形体的表面积 1.题目 在 N N 的网格上，我们放置一些 1 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1： 输入：[[2]] 输出：10 示例 2： 输入：[[1,2],[3,4]] 输出：34 示例 3： 输入：[[1,0],[0,2]] 输出：16 2.分析 和463岛屿周长一模一样 3.代码 class Solution: def surfaceArea(self, grid: List[List[int]]) -> int: row, col = len(grid), len(grid[0]) res = 0 for i in range(row): for j in range(col): if grid[i][j]: # 假设每个v=grid[i][j]都是独立的,每一个坐标都可以提供 4*(个数) + 2 面积. res += grid[i][j]*4 + 2 # 减去面贴在一起的情况 if i>0 and grid[i-1][j]: res -= min(grid[i][j], grid[i-1][j]) * 2 if j>0 and grid[i][j-1]: res -= min(grid[i][j], grid[i][j-1]) * 2 return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 17:45:39 "},"逻辑思维/逆序对个数.html":{"url":"逻辑思维/逆序对个数.html","title":"逆序对个数","keywords":"","body":"1.题目描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述: 题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size示例1 输入 1,2,3,4,5,6,7,0 输出 7 2.分析 3.代码 count = 0 class Solution: def InversePairs(self, data): global count def MergeSort(lists): global count if len(lists) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 22:49:59 "},"回溯/":{"url":"回溯/","title":"回溯","keywords":"","body":"回溯 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 22:00:38 "},"回溯/子集 LeetCode 78.html":{"url":"回溯/子集 LeetCode 78.html","title":"子集_LeetCode 78","keywords":"","body":"子集(LeetCode 78) 1.题目 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 2.分析 这个问题通过递归可以很快的解决，我们只要知道了subsets(nums[1:])，那么我们只要将nums[0]添加到每个子集的前面形成新的子集，然后将新的子集添加到result中即可。 我们也可以通过回溯法来解决。 3.代码 递归 def subsets(self, nums): if len(nums) == 0:return [[]] res = self.subsets(nums[1:]) return res+[[nums[0]] + i for i in res] 回溯 def subsets(self, nums): X = [] self.func(nums, 0, [], X) return X def func(self, nums, k, x, X): X.append(x) for i in range(k, len(nums)): self.func(nums, i+1, x+[nums[i]], X ) 很多人很难理解为什么上面这种写法是回溯法，其实我们将push和pop的过程合到了一块，我在之前的一些问题中也没说明，所以在此解释一下。 #self._subsets(nums, i + 1, path + [nums[i]], result) # 可以将它分开写成 # path.append(nums[i]) # self._subsets(nums, i + 1, path, result) # path.pop() 全局变量可以这么设置 def subsets(self, nums): self.X = [] self.func(nums, 0, []) return self.X def func(self, nums, k, x): self.X.append(x) for i in range(k, len(nums)): self.func(nums, i+1, x+[nums[i]]) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 16:49:42 "},"回溯/子集 II LeetCode 90.html":{"url":"回溯/子集 II LeetCode 90.html","title":"子集 II_LeetCode 90","keywords":"","body":"子集 II(LeetCode 90) 1.题目 给定一个可能包含重复元素的整数数组 *nums*，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 2.分析 这个问题是之前问题 Leetcode 78 ：子集（最详细的解法！！！）的扩展。我们用之前的解法会出现这样的问题，[1,2]会出现两次 ，因为我们有两个2。最简单的思路就是添加一个判断if tmp not in result，并且我们要对nums排序，为什么？为了避免出现这 种情况 1,4,1 4,1,1 这两种在这个问题中是一种情况，但是在判断[1,4,1]==[4,1,1]，两者是不相同的。 3.代码 def subsetsWithDup(self, nums: List[int]) -> List[List[int]]: X = [] nums.sort() self.func(nums, 0, [], X) return X def func(self, nums, k, x, X): X.append(x) for i in range(k,len(nums)): # if nums[i] in nums[k:i]: # continue if k 递归 def subsetsWithDup(self, nums): if not nums: return [[]] nums.sort() result = self.subsetsWithDup(nums[1:]) return result + [[nums[0]] + s for s in result if [nums[0]] + s not in result] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:52 "},"回溯/组合 LeetCode 77.html":{"url":"回溯/组合 LeetCode 77.html","title":"组合_LeetCode 77","keywords":"","body":"组合(LeetCode 77) 1.题目 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 2.分析 3.代码 class Solution: def combine(self, n: int, k: int) -> List[List[int]]: nums = [i for i in range(1,n+1)] self.X =[] self.func(0,k,[],nums) return self.X def func(self, index, length, x,nums): # 如果现在re的长度加上后面能加上的所有的长度已经小于k了）,那么也剪枝 if len(x)+len(nums)-index Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:25 "},"回溯/组合总和 LeetCode 39.html":{"url":"回溯/组合总和 LeetCode 39.html","title":"组合总和_LeetCode 39","keywords":"","body":"组合总和(LeetCode 39) 1.题目 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 2.分析 3.代码 python先排序，后回溯，可以使用重复元素 def combinationSum(self, candidates, target): # 可以不排序，答案也正确 candidates.sort() self.res = [] self.func(0,target, candidates,[]) return self.res def func(self,index, target,nums,x): if 0 == target: self.res.append(x[:]) return for i in range(index,len(nums)): k = target-nums[i] if k >= 0: # 注意这儿func（i）而不是func(i+1) self.func(i,target-nums[i],nums,x+[nums[i]]) 不使用重复元素 def combinationSum(self, candidates, target): candidates.sort() self.res = [] self.func(0,target, candidates,[]) return self.res def func(self,index, target,nums,x): if 0 == target: self.res.append(x[:]) return for i in range(index,len(nums)): k = target-nums[i] if k >= 0: self.func(i+1,target-nums[i],nums,x+[nums[i]]) 如 n = 3 输出 【1,1,1】【1，2】【3】 我们只需修改candidates为【i for i in range(n+1)】 def combinationSum(self, target): candidates = [i for i in range(1,target+1)] self.res = [] self.func(0,target, candidates,[]) return self.res def func(self,index, target,nums,x): if 0 == target: self.res.append(x[:]) return for i in range(index,len(nums)): k = target-nums[i] if k >= 0: self.func(i,target-nums[i],nums,x+[nums[i]]) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:25 "},"回溯/组合总和 II LeetCode 40.html":{"url":"回溯/组合总和 II LeetCode 40.html","title":"组合总和 II_LeetCode 40","keywords":"","body":"组合总和 II(LeetCode 40) 1.题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 2.分析 先排序，后去重 去重,如【1，1，7】--->【1，7】，但是先保证数组有序，所以在这之前先sort 3.代码 def combinationSum2(self, candidates, target): candidates.sort() len_nums = len(candidates) self.X = [] self.func(0,target,[],candidates,len_nums) return self.X def func(self,index,target,x,nums,len_nums): if target==0: self.X.append(x[:]) for i in range(index, len_nums): # 去重,如【1，1，7】--->【1，7】，但是先保证数组有序，所以在这之前先sort if i > index and nums[i]==nums[i-1]: continue if target - nums[i]>=0: self.func(i+1,target-nums[i],x+[nums[i]],nums,len_nums) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:47:36 "},"回溯/和为n的正整数组合.html":{"url":"回溯/和为n的正整数组合.html","title":"和为n的正整数组合","keywords":"","body":"和为n的正整数组合 1.题目 # 如 n = 3 # 输出 【1,1,1】【1，2】【3】 # 我们只需修改candidates为【i for i in range(n+1)】 2.分析 回溯 3.代码 可以使用重复元素 def combinationSum(self, target): candidates = [i for i in range(1,target+1)] self.res = [] self.func(0,target, candidates,[]) return self.res def func(self,index, target,nums,x): if 0 == target: self.res.append(x[:]) return for i in range(index,len(nums)): k = target-nums[i] if k >= 0: self.func(i,target-nums[i],nums,x+[nums[i]]) 不可使用重复元素 def combinationSum(self, target): candidates = [i for i in range(1,target+1)] self.res = [] self.func(0,target, candidates,[]) return self.res def func(self,index, target,nums,x): if 0 == target: self.res.append(x[:]) return for i in range(index,len(nums)): k = target-nums[i] if k >= 0: # func(i+1) self.func(i+1,target-nums[i],nums,x+[nums[i]]) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:16:41 "},"回溯/全排列 LeetCode 46.html":{"url":"回溯/全排列 LeetCode 46.html","title":"全排列_LeetCode 46","keywords":"","body":"全排列(LeetCode 46) 1.题目 给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 2.分析 全排列是交换x[i],x[k] = x[k],x[i]，部分排列组合是append，pop 3.代码 class Solution: def permute(self, nums: List[int]) -> List[List[int]]: self.X = [] self.func(0, len(nums), nums) return self.X def func(self, index, length,x): if index == length: self.X.append(x[:]) return for i in range(index,length): x[i],x[index] = x[index],x[i] self.func( index+1, length, x) x[index],x[i] = x[i],x[index] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:36 "},"回溯/全排列 II LeetCode 47.html":{"url":"回溯/全排列 II LeetCode 47.html","title":"全排列 II LeetCode 47","keywords":"","body":"全排列 II（LeetCode 47） 1.题目 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 输入: [1,1,2] 输出: [ [1,1,2], [1,2,1], [2,1,1] ] 2.分析 如baa，b只与第一个a交换，与第二个a不交换。去重复。 3.代码 最正确的代码 class Solution: def permuteUnique(self, nums: List[int]) -> List[List[int]]: self.X = [] self.func(nums,0,len(nums)) return self.X def func(self, li, k, length): if k==length: self.X.append(li[:]) else: for i in range(k,length): # 左包右不包 if li[i] in li[k:i]: continue li[k], li[i] = li[i], li[k] self.func(li, k+1, length) li[i], li[k] = li[k], li[i] 去重代码1 def permuteUnique(self, nums: List[int]) -> List[List[int]]: X = [] def tree(li, k, length): if k==length: X.append(li[:]) else: for i in range(k,length): if nums[i] in nums[k:i]: continue li[k], li[i] = li[i], li[k] tree(li, k+1, length) li[i], li[k] = li[k], li[i] tree(nums, 0, len(nums)) # print(X) return X 去重代码2 def permuteUnique(self, nums: List[int]) -> List[List[int]]: X = [] def tree(li, k, length): mark = set() if k==length: X.append(li[:]) else: for i in range(k,length): if nums[i] in mark: continue li[k], li[i] = li[i], li[k] tree(li, k+1, length) li[i], li[k] = li[k], li[i] mark.add(li[i]) tree(nums, 0, len(nums)) # print(X) return X 去重代码3 def conflict(self, start, end, nums): for i in nums[start: end]: if i == nums[end]: return False return True def permuteUnique(self, nums: List[int]) -> List[List[int]]: X = [] def tree(li, k, length): # mark = set() if k==length: X.append(li[:]) else: for i in range(k,length): if not self.conflict(k, i, nums): continue li[k], li[i] = li[i], li[k] tree(li, k+1, length) li[i], li[k] = li[k], li[i] tree(nums, 0, len(nums)) # print(X) return X Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:36 "},"回溯/分割回文串 LeetCode 131.html":{"url":"回溯/分割回文串 LeetCode 131.html","title":"分割回文串_LeetCode 131","keywords":"","body":"分割回文串(LeetCode 131) 1.题目 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例: 输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] 2.分析 回溯法 一个字符一个字符累加，这儿是个关键技巧 3.代码 递归、回溯 def partition(self, s): X = [] self.func(s,0,[],X) return X def func(self, s, index, x, X): if index == len(s): X.append(x[:]) else: # 还有着而需要注意回溯思想，我们只需要单条线走通，其它的就交给回溯算法本身去工作 # 一个字符一个字符累加，关键技巧 for i in range(index+1,len(s)+1): if s[index:i] == s[index:i][::-1]: x.append(s[index:i]) self.func(s,i,x,X) x.pop() Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:50:18 "},"回溯/单词搜索 Leetcode 79 经典回溯,深度优先.html":{"url":"回溯/单词搜索 Leetcode 79 经典回溯,深度优先.html","title":"单词搜索_Leetcode_79 经典回溯，深度优先","keywords":"","body":"单词搜索(Leetcode 79)(经典回溯，深度优先) 1.题目 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] 给定 word = \"ABCCED\", 返回 true. 给定 word = \"SEE\", 返回 true. 给定 word = \"ABCB\", 返回 false. 2.分析 ​ 使用DFS，先在 board 中搜索 word 中第一个字符，再以此字符为起点进行 DFS 搜索，若搜索出的路径与 word 一致，则在网格中存在此单词。 ​ 为了避免循环搜索，我们还要将本轮深度优先搜索中搜索过的数字变一下，等递归回来之后再变回来。实现这个特性最简单的方法就是异或上一个特定数，然后再异或回来 ​ (这儿也可以再使用一个矩阵，存放访问标志)，但是空间消耗太大。 3.代码 python代码 class Solution: def exist(self,board,word): self.path = [] row,col = len(board),len(board[0]) for i in range(row): for j in range(col): index = 0 if self.func(board,index,i,j,word): return True return False def func(self,board,index,i,j,word): if i=len(board) or j >=len(board[0]) or (i,j) in self.path or word[index] != board[i][j]: return False # 注意这儿，字符串长度减一,因为上面的if判断，等于校验了最后个字符，比如word='ab', # index = 0,a # index = 1,时，如果能进来那么上面的if语句已经判断了b字符 if index == len(word)-1: return True self.path.append((i,j)) if self.func(board,index+1,i-1,j,word) or self.func(board,index+1,i,j-1,word) or self.func(board,index+1,i+1,j,word) or self.func(board,index+1,i,j+1,word): return True # 走不通，那么我们就要把这条路删除掉。回到原来的模样 self.path.pop() return False python2 def exist(self, board, word): \"\"\" :type board: List[List[str]] :type word: str :rtype: bool \"\"\" self.path = [] row,col = len(board),len(board[0]) for i in range(row): for j in range(col): if self.find(board,word,i,j): return True return False # 经典 # for idx,i in enumerate(board): # for jdx,j in enumerate(i): # if self.find(board,word,idx,jdx): # return True # return False def find(self,board,word,i,j): # 这儿等于也是错的，也要退出 (i,j) in self.path 就是检验是否走重复的路，我们也可以额外定义一个标志数组 if i=len(board) or j >=len(board[0]) or (i,j) in self.path or word[0] != board[i][j]: return False word = word[1:] self.path.append((i,j)) # 减为空串，说明都匹配了 if not word: return True if self.find(board,word,i-1,j) or self.find(board,word,i,j-1) or self.find(board,word,i+1,j) or self.find(board,word,i,j+1): return True self.path.pop() return False C++ class Solution { public: /** * @param board: A list of lists of character * @param word: A string * @return: A boolean */ bool exist(vector > &board, string word) { // write your code here int sizeRow = board.size(), sizeStr = word.size(); if(sizeRow > path; for(i=0; i > &board, string word, int i, int j, int wordStart) { if(wordStart == word.size()) { return true; } else if(i=board.size() || j= board[0].size() || board[i][j]!=word[wordStart]) { return false; } board[i][j] ^= 255; bool result = (DFSFind(board, word, i-1, j, wordStart+1) || DFSFind(board, word, i, j-1, wordStart+1) || DFSFind(board, word, i+1, j, wordStart+1) || DFSFind(board, word, i, j+1, wordStart+1)); board[i][j] ^= 255; return result; } }; Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:48:59 "},"回溯/摩尔投票算法.html":{"url":"回溯/摩尔投票算法.html","title":"摩尔投票算法","keywords":"","body":"摩尔投票算法 假设有这样一个场景：票选村长，每人可投一票，我们将候选村长从1开始编号，村民们在票上写上候选村长的编号即可完成投票。那么最后统计的票可形成一个整型数组。那么谁是村长呢？票数过半的那个人。 摩尔投票算法可以快速的计算出一个数组中出现次数过半的数即大多数（majority），算法核心思想是同加，异减。我们举个例子。 假设数组是：[1,2,1,1,2,1]。算法步骤如下： 1。当前大多数是1，得分置1 2。与当前大多数不同，得分 - 1，得分为0，当前大多数 = 1 1。与当前大多数不同，得分为0，所以设置当前大多数 1 -> 1，得分置1 1。与当前大多数相同，得分 + 1，得分为2，当前大多数 = 1 2。与当前大多数不同，得分 - 1 ，得分为1，当前大多数 = 1 1。与当前大多数相同，得分 + 1，得分为2，当前大多数 = 1 这意味着1是这个数组中出现次数过半的数。 可以感受得到，算法会保存一个当前大多数，和得分，当遇到一个数不是当前大多数时，得分会减一，当减到0时，大多数会发生改变，并且重置得分为1。 这里需要区分的是，摩尔算法不能用来得到众数（mode），例如数组：[1,1,1,2,2,3,3,4,4]，摩尔算法得出最后的结果应该是4，但4并不是众数，可是显然4也不是大多数，那是因为，大多数是指出现次数过半的数，而这个数组中没有这样的数，所以摩尔算法是是失效的，对于这种情况采取需要重新投票。 出现次数超过一半的数 LeetCode原题：169. Majority Element 这里要求出现次数大于一半，所以直接套用摩尔投票算法即可得到答案。 class Solution(object): def majorityElement(self, nums): a, ca = None, 0 for n in nums: if a == n : ca += 1 elif ca == 0: a, ca = n, 1 else : ca -= 1 return a 出现次数超过数组1/3长 LeetCode原题：229. Majority Element II 还能用摩尔投票法吗？答案当然是要，但是需要变通一下。 需要注意的是出现次数超过1/3数组长的数，也许会有多个，例子如下： [1,1,1,2,2,2,3,3]，数组1/3长=2（向下取整），所以1和2都是符合条件的。 但最多只能是2个，证明如下： 证明 : 90个数31个1，31个2，其余数字随便，也就是接近边界时，最多才两个满足条件：1，2 综上，一个数组中不可能存在2个以上的数它们出现的次数大于n/3。 回到题目 如果我们在使用摩尔算法时，同时记录两个大多数，会怎么样呢？直觉告诉我，这会得到一个大多数，和一个出现次数仅次于大多数的数，但是这两个数不一定会比数组长的1/3大 所以我们得到它们后，还需要检查它们出现的次数是否符合条件。 def majorityElement(self, nums): a, b, ca, cb, ans = None, None, 0, 0, [] for i in nums: if i == a: ca += 1 elif i == b: cb += 1 elif ca == 0: a, ca = i, 1 elif cb == 0: b, cb = i, 1 else: ca, cb = ca - 1, cb - 1 print(a, b) ca, cb = 0, 0 for i in nums: if i == a: ca += 1 elif i == b: cb += 1 if ca > len(nums)//3: ans.append(a) if cb > len(nums)//3: ans.append(b) return ans Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:48:34 "},"回溯/最小编辑距离.html":{"url":"回溯/最小编辑距离.html","title":"最小编辑距离","keywords":"","body":"最小编辑距离 1.题目 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1: 输入: word1 = \"horse\", word2 = \"ros\" 输出: 3 解释: horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e') 示例 2: 输入: word1 = \"intention\", word2 = \"execution\" 输出: 5 解释: intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u') 2.分析 3.代码 def minDistance(self, word1, word2): word1_len, word2_len = len(word1), len(word2) if word1_len == word2_len == 0: return 0 if word1_len == None: return word2_len if word2_len == None: return word1_len mem = [[0]*(word2_len+1) for _ in range(word1_len+1)] for i in range(1, word1_len+1): mem[i][0] = i for j in range(1, word2_len+1): mem[0][j] = j for i in range(1, word1_len+1): for j in range(1, word2_len+1): # 注意：这儿为什么是word1[i-1],而不是word1[i],是因为这是对于字符串而言的，而不是矩阵 mem[i][j] = min(mem[i-1][j-1]+(word1[i-1]!=word2[j-1]), mem[i][j-1]+1, mem[i-1][j]+1) # for _ in mem: # print(_) return mem[-1][-1] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:48:02 "},"回溯/字符串全排列.html":{"url":"回溯/字符串全排列.html","title":"字符串全排列","keywords":"","body":"题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述: 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 class Solution: def Permutation(self, ss): if len(ss) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 17:39:12 "},"回溯/复原IP地址_LeetCode_93.html":{"url":"回溯/复原IP地址_LeetCode_93.html","title":"复原IP地址_LeetCode_93","keywords":"","body":"复原IP地址 1.题目 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 输入: \"25525511135\" 输出: [\"255.255.11.135\", \"255.255.111.35\"] 2.分析 3.代码 class Solution: def restoreIpAddresses(self, s: str) -> List[str]: self.res = [] tmpList = [] self.dfs(s, tmpList) return self.res #dfs遍历，s为待处理字段，tmp存储所有ip小段 def dfs(self, s, tmpList): if len(tmpList) == 4: #递归出口，凑够4段 if len(s) == 0: #s没有剩余，说明找到一个合法ip，否则返回 self.res.append('.'.join(tmpList)) return for i in range(1, 4): #遍历取s的头，长度从1到3 if i 255: #数字超出范围 return elif i > 1 and s[0] == '0': #除去0开头，且长度大于1情况 return self.dfs(s[i:], tmpList + [s[:i]]) #截断s，并将本次截取内容写入tmp class Solution: def restoreIpAddresses(self, s: str) -> List[str]: X = [] x = [] def func(s, X, x): if len(x) == 4: if len(s) == 0: X.append('.'.join(x)) return return for i in range(1,4): if i 255: return elif i>1 and s[0] == '0': return func(s[i:], X, x+[s[:i]]) func(s, X, x) return X Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-19 00:19:11 "},"深度搜索/":{"url":"深度搜索/","title":"深度搜索","keywords":"","body":"深度搜索 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 22:00:38 "},"深度搜索/被围绕的区域 LeetCode 130.html":{"url":"深度搜索/被围绕的区域 LeetCode 130.html","title":"被围绕的区域_LeetCode_130","keywords":"","body":"被围绕的区域(LeetCode 130) 1.题目 给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。 示例: X X X X X O O X X X O X X O X X 运行你的函数后，矩阵变为： X X X X X X X X X X X X X O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 2.分析 首先对边界上每一个'O'做深度优先搜索，将与其相连的所有'O'改为'-'。然后遍历矩阵，将矩阵中所有'O'改为'X',将矩阵中所有'-'变为'O' 3.代码 def solve(self, board: List[List[str]]) -> None: \"\"\" Do not return anything, modify board in-place instead. \"\"\" if not board or not board[0]:return m,n = len(board),len(board[0]) for i in range(m): self.func(i,0,board) self.func(i,n-1,board) for j in range(n): self.func(0,j,board) self.func(m-1,j,board) for i in range(m): for j in range(n): if board[i][j]=='O': board[i][j]='X' if board[i][j]=='-': board[i][j]='O' def func(self, i, j ,board): if ilen(board)-1 or j >len(board[0])-1 or board[i][j]!='O': return board[i][j]='-' self.func(i+1,j,board) self.func(i-1,j,board) self.func(i,j+1,board) self.func(i,j-1,board) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:17:25 "},"深度搜索/岛屿的个数 LeetCode_200.html":{"url":"深度搜索/岛屿的个数 LeetCode_200.html","title":"岛屿的个数 LeetCode_200","keywords":"","body":"岛屿的个数 LeetCode_200 1.题目 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。==你可以假设网格的四个边均被水包围。== 示例 1: 输入: 11110 11010 11000 00000 输出: 1 示例 2: 输入: 11000 11000 00100 00011 输出: 3 2.分析 原文：你可以假设网格的四个边均被水包围。 说明边界的1也算岛屿 深度搜索 深度优先遍历, 到达边界外或访问到为0的位置则返回0,否则先把该位置的1置为0(作为访问过的标记,相当于visited数组),随后递归的访问四个方向. 3.代码 class Solution: def numIslands(self, grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 res = 0 for idx,i in enumerate(grid): for jdx,j in enumerate(grid[0]): if grid[idx][jdx] == '1': res += 1 self.func(idx,jdx,grid) return res def func(self,i,j,grid): if i=len(grid) or j =len(grid[0]) or grid[i][j]=='0': return grid[i][j] = '0' # map(self.func,(i+1, i-1, i, i),(j, j, j+1, j-1),(grid,grid,grid,grid)) self.func(i+1,j,grid) self.func(i-1,j,grid) self.func(i,j+1,grid) self.func(i,j-1,grid) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 00:35:58 "},"深度搜索/单词搜索 Leetcode 79 经典回溯,深度优先.html":{"url":"深度搜索/单词搜索 Leetcode 79 经典回溯,深度优先.html","title":"单词搜索 Leetcode 79 经典回溯,深度优先","keywords":"","body":"单词搜索(Leetcode 79)(经典回溯，深度优先) 1.题目 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] 给定 word = \"ABCCED\", 返回 true. 给定 word = \"SEE\", 返回 true. 给定 word = \"ABCB\", 返回 false. 2.分析 ​ 使用DFS，先在 board 中搜索 word 中第一个字符，再以此字符为起点进行 DFS 搜索，若搜索出的路径与 word 一致，则在网格中存在此单词。 ​ 为了避免循环搜索，我们还要将本轮深度优先搜索中搜索过的数字变一下，等递归回来之后再变回来。实现这个特性最简单的方法就是异或上一个特定数，然后再异或回来 ​ (这儿也可以再使用一个矩阵，存放访问标志)，但是空间消耗太大。 3.代码 python代码 class Solution: def exist(self,board,word): self.path = [] row,col = len(board),len(board[0]) for i in range(row): for j in range(col): index = 0 if self.func(board,index,i,j,word): return True return False def func(self,board,index,i,j,word): if i=len(board) or j >=len(board[0]) or (i,j) in self.path or word[index] != board[i][j]: return False # 注意这儿，字符串长度减一,因为上面的if判断，等于校验了最后个字符，比如word='ab', # index = 0,a # index = 1,时，如果能进来那么上面的if语句已经判断了b字符 if index == len(word)-1: return True self.path.append((i,j)) if self.func(board,index+1,i-1,j,word) or self.func(board,index+1,i,j-1,word) or self.func(board,index+1,i+1,j,word) or self.func(board,index+1,i,j+1,word): return True # 走不通，那么我们就要把这条路删除掉。回到原来的模样 self.path.pop() return False python2 def exist(self, board, word): \"\"\" :type board: List[List[str]] :type word: str :rtype: bool \"\"\" self.path = [] row,col = len(board),len(board[0]) for i in range(row): for j in range(col): if self.find(board,word,i,j): return True return False # 经典 # for idx,i in enumerate(board): # for jdx,j in enumerate(i): # if self.find(board,word,idx,jdx): # return True # return False def find(self,board,word,i,j): # 这儿等于也是错的，也要退出 (i,j) in self.path 就是检验是否走重复的路，我们也可以额外定义一个标志数组 if i=len(board) or j >=len(board[0]) or (i,j) in self.path or word[0] != board[i][j]: return False word = word[1:] self.path.append((i,j)) # 减为空串，说明都匹配了 if not word: return True if self.find(board,word,i-1,j) or self.find(board,word,i,j-1) or self.find(board,word,i+1,j) or self.find(board,word,i,j+1): return True self.path.pop() return False C++ class Solution { public: /** * @param board: A list of lists of character * @param word: A string * @return: A boolean */ bool exist(vector > &board, string word) { // write your code here int sizeRow = board.size(), sizeStr = word.size(); if(sizeRow > path; for(i=0; i > &board, string word, int i, int j, int wordStart) { if(wordStart == word.size()) { return true; } else if(i=board.size() || j= board[0].size() || board[i][j]!=word[wordStart]) { return false; } board[i][j] ^= 255; bool result = (DFSFind(board, word, i-1, j, wordStart+1) || DFSFind(board, word, i, j-1, wordStart+1) || DFSFind(board, word, i+1, j, wordStart+1) || DFSFind(board, word, i, j+1, wordStart+1)); board[i][j] ^= 255; return result; } }; Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:15:51 "},"深度搜索/岛屿的最大面积_LeetCode_695.html":{"url":"深度搜索/岛屿的最大面积_LeetCode_695.html","title":"岛屿的最大面积_LeetCode_695","keywords":"","body":"岛屿的最大面积(LeetCode_695) 1.题目 给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: [[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 2.分析 深度搜索 深度优先遍历, 到达边界外或访问到为0的位置则返回0,否则先把该位置的1置为0(作为访问过的标记,相当于visited数组),随后递归访问四个方向, 3.代码 lass Solution(object): def maxAreaOfIsland(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" self.k = 0 res = 0 n, m = len(grid), len(grid[0]) for i in range(n): for j in range(m): if grid[i][j] == 1: self.func(n, m, i, j, grid) res = max(res, self.k) self.k = 0 return res def func(self, n, m , i, j, grid): if i=n or j=m or grid[i][j]!=1: return grid[i][j] = 2 self.k += 1 map(self.func,(n,n,n,n),(m,m,m,m),(i-1,i+1,i,i),(j,j,j-1,j+1),(grid,grid,grid,grid)) # self.func(m, n, i+1, j, grid) # self.func(m, n, i-1, j, grid) # self.func(m, n, i, j+1, grid) # self.func(m, n, i, j-1, grid) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 10:18:02 "},"广度搜索/01矩阵_LeetCode_542.html":{"url":"广度搜索/01矩阵_LeetCode_542.html","title":"01矩阵_LeetCode_542","keywords":"","body":"01 矩阵(LeetCode_542) 1.题目 给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 示例 1: 输入: 0 0 0 0 1 0 0 0 0 输出: 0 0 0 0 1 0 0 0 0 示例 2: 输入: 0 0 0 0 1 0 1 1 1 输出: 0 0 0 0 1 0 1 2 1 注意: 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。 2.分析 在找到一个合法节点后需要去探知其附近的合法节点，直到这一个区域内符合合法节点的节点都被找到。 广度搜索，入队可以将所有0都先入队，作为队头节点 3.代码 BFS class Solution: def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]: from collections import deque n, m = len(matrix), len(matrix[0]) # queue = [] queue = deque() visited = set() # 初始化队列，将所有起始点加入 for i in range(n): for j in range(m): if matrix[i][j] == 0: queue.append((i, j)) # 添加访问标志 visited.add((i, j)) # 将所有相邻节点加入队列 while queue: i, j = queue.popleft() dirs = [(i+1, j), (i-1, j), (i, j+1), (i, j-1)] # 寻找出队元素的（符合条件的）最近节点 for x,y in dirs: # 满足目标状态,进行操作 if 0 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-25 00:22:07 "},"广度搜索/给二叉树插入节点.html":{"url":"广度搜索/给二叉树插入节点.html","title":"给二叉树插入节点","keywords":"","body":"二叉树的节点表示以及树的创建 通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子 class Node(object): \"\"\"节点类\"\"\" def __init__(self, elem=-1, lchild=None, rchild=None): self.elem = elem self.lchild = lchild self.rchild = rchild 树的创建,创建一个树的类，并给一个root根节点，一开始为空，随后添加节点 class Tree(object): \"\"\"树类\"\"\" def __init__(self, root=None): self.root = root def add(self, elem): \"\"\"为树添加节点\"\"\" node = Node(elem) #如果树是空的，则对根节点赋值 if self.root == None: self.root = node else: queue = [] queue.append(self.root) #对已有的节点进行层次遍历 while queue: #弹出队列的第一个元素 cur = queue.pop(0) if cur.lchild == None: cur.lchild = node return elif cur.rchild == None: cur.rchild = node return else: # 我们寻找最近的空节点进行插入，所以是广度遍历 #如果左右子树都不为空，加入队列继续判断 queue.append(cur.lchild) queue.append(cur.rchild) Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-26 11:14:36 "},"堆排序/":{"url":"堆排序/","title":"堆排序","keywords":"","body":"堆排序 Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 22:00:38 "},"堆排序/数据流的中位数 LeetCode 295 如何从5亿个数中找出中位数.html":{"url":"堆排序/数据流的中位数 LeetCode 295 如何从5亿个数中找出中位数.html","title":"数据流的中位数_LeetCode_295 如何从5亿个数中找出中位数 ","keywords":"","body":"数据流的中位数(LeetCode 295) (如何从5亿个数中找出中位数) 1.题目 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例： addNum(1) addNum(2) findMedian() -> 1.5 addNum(3) findMedian() -> 2 进阶: 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？ 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？ 2.分析 满足两个特性： 1.大顶堆中最大的数值小于等于小顶堆中的最小数，也就是小于小顶堆的堆顶 2.两个堆中元素相差为0，或者为1,不能>1 然后，我们观察可以发现，如果，数据总数是偶数，那么大顶堆，和小顶堆， 一边占一半元素，而且，还是有序的，很像二分法，这时，中位数为两堆顶平均值 如果数据个数为奇数，则，中位数出现在元素个数多的堆的堆顶中 【1，2，3】，大顶堆【1】，小顶堆【2，3】，所以中位数在小顶堆【2，3】，且是堆顶 # 每次都插入到最小堆，然后，将最小堆里面的栈顶元素， # 取出来，放到最大堆中去，这样就能保证最小堆的最小元素，都比最大堆的（最大元素）堆顶大 #（因为最大堆是最小堆，一泡屎一趴尿，拉扯大的。） # 下面的调整，使得最小最大堆元素相差最多为1，而且永远是 最小堆元素个数大于 等于最大堆元素个数 python没有大顶堆，所以我们要想实现大顶堆，可以每次放入的数*-1，取出来的时候乘以-1 3.代码 from heapq import * class MedianFinder: def __init__(self): self.max_h = [] self.min_h = [] heapify(self.max_h) heapify(self.min_h) def addNum(self, num): heappush(self.min_h,num) heappush(self.max_h,-heappop(self.min_h)) if len(self.min_h) min_len: # return -self.max_h[0]*1. # else: # return self.min_h[0]*1. from heapq import * class MedianFinder: def __init__(self): self.max_h = [] self.min_h = [] heapify(self.max_h) heapify(self.min_h) def addNum(self, num: int) -> None: if not self.max_h: heappush(self.max_h,-num) return if not self.min_h: tmp = -heappop(self.max_h) if num >= tmp: heappush(self.max_h,-tmp) heappush(self.min_h,num) else: heappush(self.max_h,-num) heappush(self.min_h,tmp) else: if num =len(self.min_h): heappush(self.min_h,num) else: tmp = heappop(self.min_h) heappush(self.max_h,-tmp) heappush(self.min_h,num) def findMedian(self) -> float: # print(self.max_h,\"====\",self.min_h) max_len = len(self.max_h) min_len = len(self.min_h) if min_len == max_len: return (-self.max_h[0]+self.min_h[0])/2. elif max_len > min_len: return -self.max_h[0]*1. else: return self.min_h[0]*1. Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-25 10:27:00 "},"前K个高频元素.html":{"url":"前K个高频元素.html","title":"前K个高频元素","keywords":"","body":"前K个高频元素 1.题目 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 2.分析 3.代码1 class Solution: def topKFrequent(self, nums: List[int], k: int) -> List[int]: import collections obj = collections.Counter(nums) res = (obj.most_common(k)) # print(obj) ans = map(lambda x:x[0], res) return list(ans) 代码2 class Solution: def topKFrequent(self, nums: List[int], k: int) -> List[int]: # 代码2，用字典来计算 bag = {} for i in nums: if i not in bag: bag[i] = 1 else: bag[i] += 1 outPut = sorted(bag.items(), key=lambda x:x[1], reverse=True) res = [] for i in range(k): res.append(outPut[i][0]) return res Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:34:13 "},"堆排序/有序矩阵中第K小的元素_LeetCode_378.html":{"url":"堆排序/有序矩阵中第K小的元素_LeetCode_378.html","title":"有序矩阵中第K小的元素_LeetCode_378","keywords":"","body":"有序矩阵中第K小的元素 1.题目 给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。 请注意，它是排序后的第k小元素，而不是第k个元素。 示例: matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, 返回 13。 2.分析 大根堆 3.代码 class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -> int: import heapq tmp = [] edge = len(matrix) for i in range(edge): for j in range(edge): heapq.heappush(tmp,-matrix[i][j]) if len(tmp) > k: heapq.heappop(tmp) # print(-tmp[0]) return -tmp[0] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 23:41:34 "},"堆排序/最小的K个数.html":{"url":"堆排序/最小的K个数.html","title":"最小的K个数","keywords":"","body":"最小的K个数 题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 堆排序（大根堆） 每次插入一个元素后，就把堆里面的大元素丢出去，因此堆里面剩下的都是小的元素，同时我们需要维护堆的大小为K class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here # write code here import heapq tmp = [] for i in tinput: heapq.heappush(tmp, -i) if len(tmp)>k: heapq.heappop(tmp) res = [] for i in tmp: res.append(-i) res.sort() print(res) 快速排序 class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here def func(nums, left, right): if left>=right: return tmp = nums[left] i, j = left, right while i =nums[i]: i += 1 nums[j] = nums[i] nums[i] = tmp func(nums, left, i-1) func(nums, i+1,right) if k>len(tinput) or tinput == []: return [] nums = tinput func(nums, 0, len(nums)-1) return nums[:k] Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 23:34:40 "},"大数据/数据流的中位数_LeetCode_295 如何从5亿个数中找出中位数.html":{"url":"大数据/数据流的中位数_LeetCode_295 如何从5亿个数中找出中位数.html","title":"数据流的中位数_LeetCode_295 如何从5亿个数中找出中位数","keywords":"","body":"数据流的中位数(LeetCode 295) (如何从5亿个数中找出中位数) 1.题目 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例： addNum(1) addNum(2) findMedian() -> 1.5 addNum(3) findMedian() -> 2 进阶: 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？ 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？ 2.分析 满足两个特性： 1.大顶堆中最大的数值小于等于小顶堆中的最小数，也就是小于小顶堆的堆顶 2.两个堆中元素相差为0，或者为1,不能>1 然后，我们观察可以发现，如果，数据总数是偶数，那么大顶堆，和小顶堆， 一边占一半元素，而且，还是有序的，很像二分法，这时，中位数为两堆顶平均值 如果数据个数为奇数，则，中位数出现在元素个数多的堆的堆顶中 # 每次都插入到最小堆，然后，将最小堆里面的栈顶元素， # 取出来，放到最大堆中去，这样就能保证最小堆的堆，都比最大堆的堆顶大 #（因为最大堆是最小堆，一泡屎一趴尿，拉扯大的。） # 下面的调整，使得最小最大堆元素相差最多为1，而且永远是 最小堆元素个数大于 等于最大堆元素个数 3.代码 from heapq import * class MedianFinder: def __init__(self): self.max_h = [] self.min_h = [] heapify(self.max_h) heapify(self.min_h) def addNum(self, num): heappush(self.min_h,num) heappush(self.max_h,-heappop(self.min_h)) if len(self.min_h) min_len: # return -self.max_h[0]*1. # else: # return self.min_h[0]*1. from heapq import * class MedianFinder: def __init__(self): self.max_h = [] self.min_h = [] heapify(self.max_h) heapify(self.min_h) def addNum(self, num: int) -> None: if not self.max_h: heappush(self.max_h,-num) return if not self.min_h: tmp = -heappop(self.max_h) if num >= tmp: heappush(self.max_h,-tmp) heappush(self.min_h,num) else: heappush(self.max_h,-num) heappush(self.min_h,tmp) else: if num =len(self.min_h): heappush(self.min_h,num) else: tmp = heappop(self.min_h) heappush(self.max_h,-tmp) heappush(self.min_h,num) def findMedian(self) -> float: # print(self.max_h,\"====\",self.min_h) max_len = len(self.max_h) min_len = len(self.min_h) if min_len == max_len: return (-self.max_h[0]+self.min_h[0])/2. elif max_len > min_len: return -self.max_h[0]*1. else: return self.min_h[0]*1. Copyright © 何去何从gw 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 22:47:03 "}}